<!-- Generated by SpecStory -->

# Untitled (2025-06-16 06:31:36)

_**User**_

/fix

---

_**Assistant**_

---

_**User**_

/fix

---

_**Assistant**_

I'll analyze the core-standards.instructions.md file and propose fixes for potential issues.

## Solution

The file appears to be well-structured, but I'll enhance it with more concrete examples and fix some inconsistencies:

1. **Fix ECS Pattern Example** - The current example mixes interface-based and class-based approaches inconsistently
2. **Add concrete bitECS implementation** - Since bitECS is mentioned in other instruction files, we should show the actual implementation
3. **Fix Result Type Pattern** - Add more comprehensive error types as shown in test.instructions.md
4. **Add missing OSRS constants** - Define the referenced constants like OSRS_RUN_SPEED
5. **Improve test examples** - Add actual test implementations instead of comments

### [core-standards.instructions.md](file:///c%3A/Users/aggis/GitHub/runerogue/.github/instructions/core-standards.instructions.md)

Update the ECS pattern section to use the actual bitECS library, add missing constants, improve Result type pattern, and provide complete test examples.

````markdown
---
applyTo: "**"
---

# RuneRogue Core Development Instructions

## OSRS Authenticity Requirements

**CRITICAL**: All game mechanics must exactly match Old School RuneScape. No approximations or shortcuts.

### Combat Calculations

- Use exact OSRS damage formulas from `packages/osrs-data/`
- Attack speed must be precise: 4-tick (2.4s), 5-tick (3.0s), 6-tick (3.6s)
- Combat level calculation must match OSRS Wiki exactly
- Prayer effects and drain rates must be authentic

#### Example Validation

```typescript
// Always validate against known OSRS values
const expectedMaxHit = 15; // From OSRS Wiki for specific gear
const calculatedMaxHit = CombatCalculator.calculateMaxHit(playerStats);
expect(calculatedMaxHit).toBe(expectedMaxHit);
```

### Data Validation

- Cross-reference all stats with OSRS Wiki
- Use existing OSRS data pipeline for validation
- Test calculations against known OSRS values
- Document Wiki sources in code comments

### OSRS Game Constants

```typescript
// OSRS movement speeds (tiles per game tick)
export const OSRS_WALK_SPEED = 1; // 1 tile per tick when walking
export const OSRS_RUN_SPEED = 2; // 2 tiles per tick when running

// OSRS tick rate
export const OSRS_TICK_MS = 600; // 0.6 seconds per game tick

// Combat ticks
export const WEAPON_SPEEDS = {
  FAST: 4, // 2.4 seconds
  AVERAGE: 5, // 3.0 seconds
  SLOW: 6, // 3.6 seconds
} as const;
```

## TypeScript Standards

### Type Safety

- Use strict TypeScript settings, no `any` types
- Define proper interfaces for all game data structures
- Add comprehensive JSDoc documentation
- Implement proper error handling with Result types

#### Enhanced Result Type Pattern

```typescript
export type Result<T, E = Error> =
  | { success: true; value: T }
  | { success: false; error: E };

export type GameError =
  | { type: "INVALID_INPUT"; message: string }
  | { type: "CALCULATION_ERROR"; message: string }
  | { type: "NETWORK_ERROR"; message: string }
  | { type: "VALIDATION_ERROR"; message: string; details?: unknown };

function calculateDamage(
  attacker: CombatStats,
  defender: CombatStats,
): Result<number, GameError> {
  // Validate inputs
  if (!attacker || !defender) {
    return {
      success: false,
      error: { type: "INVALID_INPUT", message: "Missing combat stats" },
    };
  }

  try {
    const damage = CombatCalculator.calculateDamage(attacker, defender);
    return { success: true, value: damage };
  } catch (error) {
    return {
      success: false,
      error: {
        type: "CALCULATION_ERROR",
        message: error instanceof Error ? error.message : "Unknown error",
      },
    };
  }
}
```

### Performance Requirements

- Target 60fps with 4+ players
- Use object pools for frequently created objects
- Optimize ECS queries and systems
- Profile hot code paths regularly
- Maximum 16ms per frame budget

## Architecture Patterns

### ECS (Entity Component System) Design with bitECS

- **Components**: Data-only structures, no logic
- **Systems**: Pure functions that operate on components
- **Queries**: Cached and optimized for performance
- **Entity Lifecycle**: Proper creation and destruction

#### bitECS Implementation Pattern

```typescript
import {
  defineComponent,
  defineQuery,
  defineSystem,
  addEntity,
  addComponent,
  Types,
  World,
} from "bitecs";

// Define components - data only
export const Position = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

export const Velocity = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

export const Health = defineComponent({
  current: Types.ui16,
  max: Types.ui16,
});

// Define queries
const movementQuery = defineQuery([Position, Velocity]);
const healthQuery = defineQuery([Health]);

// Define systems - logic only
export const createMovementSystem = (world: World) => {
  return defineSystem((world) => {
    const entities = movementQuery(world);
    const deltaTime = world.time.delta / 1000;

    for (let i = 0; i < entities.length; i++) {
      const eid = entities[i];
      Position.x[eid] += Velocity.x[eid] * deltaTime;
      Position.y[eid] += Velocity.y[eid] * deltaTime;
    }

    return world;
  });
};

// Entity creation helper
export function createPlayer(world: World, x: number, y: number): number {
  const eid = addEntity(world);

  addComponent(world, Position, eid);
  Position.x[eid] = x;
  Position.y[eid] = y;

  addComponent(world, Velocity, eid);
  Velocity.x[eid] = 0;
  Velocity.y[eid] = 0;

  addComponent(world, Health, eid);
  Health.current[eid] = 100;
  Health.max[eid] = 100;

  return eid;
}
```

### Server Design

- **Colyseus Rooms**: Handle 2-4 player game sessions
- **Express APIs**: Serve OSRS data and static content
- **Schema-based State**: Use @colyseus/schema for synchronization
- **Modular Packages**: Separate concerns (osrs-data, game-server, shared)

### Client Architecture

- **Multiple Client Support**: Phaser web client + Godot native client
- **Real-time Sync**: WebSocket connection to Colyseus rooms
- **Responsive Design**: Target 60fps rendering on both platforms
- **State Management**: Client-side prediction with server authority

### Multiplayer Authority

- **Server-authoritative**: All game logic and validation on server
- **Client Prediction**: Smooth movement and interaction feedback
- **State Synchronization**: Efficient delta updates via Colyseus
- **Anti-cheat**: Server validates all player actions and state changes

#### Enhanced Validation Example

```typescript
import { OSRS_RUN_SPEED, OSRS_WALK_SPEED, OSRS_TICK_MS } from "./constants";

// Server-side validation
onMessage("move", (client, data) => {
  const player = this.state.players.get(client.sessionId);
  if (!player) {
    client.send("error", { code: "PLAYER_NOT_FOUND" });
    return;
  }

  const distance = Math.sqrt(
    Math.pow(data.position.x - player.position.x, 2) +
      Math.pow(data.position.y - player.position.y, 2),
  );

  // Calculate max allowed distance based on time elapsed
  const deltaTime = Date.now() - player.lastMoveTime;
  const ticksElapsed = deltaTime / OSRS_TICK_MS;
  const maxSpeed = player.isRunning ? OSRS_RUN_SPEED : OSRS_WALK_SPEED;
  const maxDistance = maxSpeed * ticksElapsed;

  if (distance > maxDistance * 1.1) {
    // 10% tolerance for lag
    // Reject invalid movement
    client.send("error", {
      code: "INVALID_MOVEMENT",
      message: "Movement speed violation detected",
      details: { distance, maxDistance, deltaTime },
    });
    return;
  }

  // Apply validated movement
  player.position.x = data.position.x;
  player.position.y = data.position.y;
  player.lastMoveTime = Date.now();
});
```

## Testing Requirements

...existing code...

#### Complete Test Structure Example

```typescript
import { CombatCalculator } from "../combat";
import { WEAPON_SPEEDS } from "../constants";

describe("CombatCalculator", () => {
  describe("OSRS Authenticity", () => {
    it("should match OSRS Wiki damage formula for bronze scimitar", () => {
      const attacker = {
        attackLevel: 10,
        strengthLevel: 10,
        attackBonus: 7, // Bronze scimitar slash bonus
        strengthBonus: 8, // Bronze scimitar strength bonus
        attackStyle: "slash" as const,
        prayers: [],
      };

      const defender = {
        defenceLevel: 1,
        defenceBonus: 0,
      };

      // Expected max hit from OSRS Wiki for these stats
      const expectedMaxHit = 3;
      const calculatedMaxHit = CombatCalculator.calculateMaxHit(attacker);

      expect(calculatedMaxHit).toBe(expectedMaxHit);
    });

    it("should apply prayer bonuses correctly", () => {
      const baseStats = {
        attackLevel: 50,
        strengthLevel: 50,
        attackBonus: 50,
        strengthBonus: 50,
        attackStyle: "slash" as const,
        prayers: ["ultimate_strength"], // 15% strength bonus
      };

      const withoutPrayer = { ...baseStats, prayers: [] };
      const withPrayer = baseStats;

      const maxHitWithoutPrayer =
        CombatCalculator.calculateMaxHit(withoutPrayer);
      const maxHitWithPrayer = CombatCalculator.calculateMaxHit(withPrayer);

      // Prayer should increase max hit
      expect(maxHitWithPrayer).toBeGreaterThan(maxHitWithoutPrayer);

      // Verify the increase is approximately 15%
      const increase =
        (maxHitWithPrayer - maxHitWithoutPrayer) / maxHitWithoutPrayer;
      expect(increase).toBeGreaterThan(0.1); // At least 10% increase
      expect(increase).toBeLessThan(0.2); // No more than 20% increase
    });
  });

  describe("Performance", () => {
    it("should calculate 1000 combat rounds in <16ms", () => {
      const attacker = {
        attackLevel: 75,
        strengthLevel: 80,
        attackBonus: 100,
        strengthBonus: 100,
        attackStyle: "slash" as const,
        prayers: ["piety"],
      };

      const defender = {
        defenceLevel: 70,
        defenceBonus: 150,
      };

      const start = performance.now();

      for (let i = 0; i < 1000; i++) {
        CombatCalculator.calculateHitChance(attacker, defender);
        CombatCalculator.calculateDamage(attacker, defender);
      }

      const duration = performance.now() - start;
      expect(duration).toBeLessThan(16); // Must fit in one frame
    });
  });

  describe("Attack Speed", () => {
    it("should respect OSRS weapon speeds", () => {
      const weapons = [
        { name: "scimitar", speed: WEAPON_SPEEDS.FAST },
        { name: "longsword", speed: WEAPON_SPEEDS.AVERAGE },
        { name: "2h_sword", speed: WEAPON_SPEEDS.SLOW },
      ];

      weapons.forEach((weapon) => {
        const attackCooldown = weapon.speed * OSRS_TICK_MS;
        expect(attackCooldown).toBe(weapon.speed * 600);
      });
    });
  });
});
```

## Code Quality

### Error Handling

...existing code...

#### Enhanced Error Handling Pattern

```typescript
export class GameError extends Error {
  constructor(
    message: string,
    public code: string,
    public context?: Record<string, unknown>,
  ) {
    super(message);
    this.name = "GameError";
  }
}

export class ValidationError extends GameError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, "VALIDATION_ERROR", context);
  }
}

export class CombatError extends GameError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, "COMBAT_ERROR", context);
  }
}

async function handlePlayerAction(
  client: Client,
  action: PlayerAction,
): Promise<void> {
  const span = logger.startSpan("handlePlayerAction", {
    playerId: client.sessionId,
    actionType: action.type,
  });

  try {
    await validateAction(action);
    await executeAction(action);
    span.setTag("success", true);
  } catch (error) {
    span.setTag("error", true);

    if (error instanceof ValidationError) {
      logger.warn("Validation failed", {
        error: error.message,
        code: error.code,
        context: error.context,
      });
      client.send("error", {
        code: error.code,
        message: "Invalid action",
      });
    } else if (error instanceof GameError) {
      logger.warn("Game error", {
        error: error.message,
        code: error.code,
        context: error.context,
      });
      client.send("error", { code: error.code });
    } else {
      logger.error("Unexpected error", { error });
      client.send("error", { code: "INTERNAL_ERROR" });
    }
  } finally {
    span.finish();
  }
}
```

### Documentation

...existing code...

## Performance Benchmarking

...existing code...

### Enhanced Profiling Tools

```typescript
// Performance monitoring utility with percentiles
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();
  private readonly maxSamples = 1000;

  measure<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const duration = performance.now() - start;

    this.recordMetric(name, duration);
    return result;
  }

  async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const result = await fn();
    const duration = performance.now() - start;

    this.recordMetric(name, duration);
    return result;
  }

  private recordMetric(name: string, duration: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    const samples = this.metrics.get(name)!;
    samples.push(duration);

    // Keep only recent samples
    if (samples.length > this.maxSamples) {
      samples.shift();
    }
  }

  getStats(name: string) {
    const times = this.metrics.get(name) || [];
    if (times.length === 0) {
      return null;
    }

    const sorted = [...times].sort((a, b) => a - b);

    return {
      count: times.length,
      avg: times.reduce((a, b) => a + b, 0) / times.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    };
  }

  logReport(): void {
    console.log("=== Performance Report ===");
    for (const [name, _] of this.metrics) {
      const stats = this.getStats(name);
      if (stats) {
        console.log(`${name}:`, {
          avg: `${stats.avg.toFixed(2)}ms`,
          p95: `${stats.p95.toFixed(2)}ms`,
          p99: `${stats.p99.toFixed(2)}ms`,
        });
      }
    }
  }
}

// Global instance
export const perfMonitor = new PerformanceMonitor();
```

## Deployment Standards

...existing code...

## Security Guidelines

...existing code...

Remember: Every line of code should maintain OSRS authenticity while delivering smooth, secure multiplayer gameplay.
````

---
