<!-- Generated by SpecStory -->

# /fix  (2025-06-21 04:40:49)

_**User**_

/fix 

---

_**Assistant**_

Looking at the NEXT_STEPS.md file, I can see there are several issues with the proposed implementation that need to be addressed for a production-ready solution. Let me provide fixes for the main problems:

## Step-by-step Solution

1. **Fix the Combat System implementation** - The current implementation has several issues including improper world extension, missing room reference, and incomplete error handling.

2. **Fix the Enemy Spawn System** - The current implementation doesn't properly handle the room reference and lacks proper cleanup.

3. **Fix the GameRoom integration** - The world needs proper type extension and the death handler needs better implementation.

4. **Fix the Client-side implementation** - Add proper helper methods and error handling.

### [index.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/game-server/src/ecs/components/index.ts)

Update the Combat component to include the attack timer fields:

````typescript
// ...existing code...

export const Combat = defineComponent({
  attack: Types.ui8,
  strength: Types.ui8,
  defence: Types.ui8,
  attackSpeed: Types.ui16, // milliseconds between attacks
  lastAttackTime: Types.f32, // timestamp of last attack
});

// Add Enemy tag component
export const Enemy = defineComponent({}); // Tag component for enemy entities

// ...existing code...
````

### [CombatSystem.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/game-server/src/ecs/systems/CombatSystem.ts)

Complete implementation with proper error handling and room reference:

````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
import { defineQuery, defineSystem, IWorld, removeEntity } from "bitecs";
import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";
import { Position, Health, Target, Combat } from "../components";
import type { GameRoom } from "../../rooms/GameRoom";

// Extend IWorld to include our custom properties
export interface CombatWorld extends IWorld {
  room: GameRoom;
  entitiesToRemove: Set<number>;
}

const combatQuery = defineQuery([Position, Health, Target, Combat]);
const targetableQuery = defineQuery([Position, Health]);

/**
 * Calculate distance between two points
 * @param x1 - X coordinate of first point
 * @param y1 - Y coordinate of first point
 * @param x2 - X coordinate of second point
 * @param y2 - Y coordinate of second point
 * @returns Distance in pixels
 */
function getDistance(
  x1: number,
  y1: number,
  x2: number,
  y2: number
): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Create the combat system that handles OSRS-authentic combat calculations
 * @param room - The game room instance for broadcasting events
 * @returns The combat system function
 */
export const createCombatSystem = (room: GameRoom) => {
  return defineSystem((world: CombatWorld) => {
    const entities = combatQuery(world);
    const currentTime = performance.now();
    const targetables = targetableQuery(world);

    for (let i = 0; i < entities.length; i++) {
      const eid = entities[i];
      const targetEid = Target.eid[eid];

      // Verify target exists and is targetable
      if (!targetEid || !targetables.includes(targetEid)) {
        Target.eid[eid] = 0; // Clear invalid target
        continue;
      }

      // Check if target is already dead
      if (Health.current[targetEid] <= 0) {
        Target.eid[eid] = 0; // Clear dead target
        continue;
      }

      // Check distance (1 tile = 32 pixels in our game)
      const distance = getDistance(
        Position.x[eid],
        Position.y[eid],
        Position.x[targetEid],
        Position.y[targetEid]
      );

      const meleeRange = 40; // Slightly more than 1 tile for melee
      if (distance > meleeRange) continue;

      // Check attack timer (stored in milliseconds)
      const lastAttackTime = Combat.lastAttackTime[eid] || 0;
      const attackSpeed = Combat.attackSpeed[eid] || 2400; // 4-tick default

      if (currentTime - lastAttackTime < attackSpeed) continue;

      // Update attack timer
      Combat.lastAttackTime[eid] = currentTime;

      try {
        // Calculate combat using OSRS formulas
        const attackerStats = {
          attackLevel: Combat.attack[eid] || 1,
          strengthLevel: Combat.strength[eid] || 1,
          defenceLevel: Combat.defence[eid] || 1,
          attackBonus: 0, // TODO: Equipment bonuses
          strengthBonus: 0,
          defenceBonus: 0,
          attackStyle: "aggressive" as const,
          combatType: "melee" as const,
          prayers: [] as string[],
        };

        const defenderStats = {
          defenceLevel: Combat.defence[targetEid] || 1,
          defenceBonus: 0, // TODO: Equipment bonuses
          attackStyle: "defensive" as const,
          combatType: "melee" as const,
          prayers: [] as string[],
        };

        // Calculate hit chance and damage
        const accuracy = calculateAccuracy(attackerStats, defenderStats);
        const maxHit = calculateMaxHit(attackerStats);

        // Roll for hit
        if (Math.random() < accuracy) {
          const damage = Math.floor(Math.random() * (maxHit + 1));
          const previousHealth = Health.current[targetEid];
          Health.current[targetEid] = Math.max(
            0,
            Health.current[targetEid] - damage
          );

          // Emit damage event for client feedback
          room.broadcast("damage", { 
            target: targetEid, 
            damage, 
            attacker: eid,
            remainingHealth: Health.current[targetEid]
          });

          // Check if target died
          if (Health.current[targetEid] <= 0 && previousHealth > 0) {
            // Mark entity for removal (don't remove during iteration)
            if (!world.entitiesToRemove) {
              world.entitiesToRemove = new Set();
            }
            world.entitiesToRemove.add(targetEid);
            
            // Clear target from attacker
            Target.eid[eid] = 0;
          }
        } else {
          // Missed attack
          room.broadcast("combatMiss", { 
            target: targetEid, 
            attacker: eid 
          });
        }
      } catch (error) {
        console.error("Combat calculation error:", error);
        // Continue to next entity rather than crashing
      }
    }

    return world;
  });
};
````

### [EnemySpawnSystem.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/game-server/src/ecs/systems/EnemySpawnSystem.ts)

Create a properly structured enemy spawn system:

````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
import { defineSystem, addEntity, addComponent, IWorld } from "bitecs";
import {
  Position,
  Velocity,
  Health,
  Target,
  Combat,
  Enemy,
} from "../components";
import { EnemySchema } from "@runerogue/shared";
import type { GameRoom } from "../../rooms/GameRoom";

interface SpawnConfig {
  health: number;
  attack: number;
  strength: number;
  defence: number;
  attackSpeed: number;
  combatLevel: number;
}

const ENEMY_CONFIGS: Record<string, SpawnConfig> = {
  goblin: {
    health: 5,
    attack: 1,
    strength: 1,
    defence: 1,
    attackSpeed: 2400, // 4 ticks
    combatLevel: 2,
  },
  spider: {
    health: 8,
    attack: 2,
    strength: 2,
    defence: 1,
    attackSpeed: 2400,
    combatLevel: 3,
  },
  orc: {
    health: 12,
    attack: 3,
    strength: 3,
    defence: 2,
    attackSpeed: 3000, // 5 ticks
    combatLevel: 5,
  },
};

/**
 * Create enemy spawn system that manages wave-based enemy spawning
 * @param room - The game room instance
 * @returns The enemy spawn system function
 */
export const createEnemySpawnSystem = (room: GameRoom) => {
  let lastSpawnTime = 0;
  const SPAWN_INTERVAL = 5000; // 5 seconds
  const MIN_SPAWN_DISTANCE = 100; // Minimum distance from players

  return defineSystem((world: IWorld) => {
    const currentTime = performance.now();

    // Check spawn interval
    if (currentTime - lastSpawnTime < SPAWN_INTERVAL) {
      return world;
    }

    // Initialize wave if needed
    if (room.state.enemiesRemaining === 0 && room.state.enemies.size === 0) {
      room.state.waveNumber++;
      room.state.enemiesRemaining = Math.min(
        3 + room.state.waveNumber * 2,
        20 // Cap at 20 enemies per wave
      );
      room.broadcast("waveStart", {
        waveNumber: room.state.waveNumber,
        enemyCount: room.state.enemiesRemaining,
      });
    }

    // Check if we should spawn enemies
    if (room.state.enemies.size < room.state.enemiesRemaining) {
      lastSpawnTime = currentTime;

      // Choose enemy type based on wave
      let enemyType = "goblin";
      if (room.state.waveNumber > 5) {
        enemyType = "orc";
      } else if (room.state.waveNumber > 3) {
        enemyType = "spider";
      }

      const config = ENEMY_CONFIGS[enemyType];
      if (!config) {
        console.error(`Unknown enemy type: ${enemyType}`);
        return world;
      }

      // Find a valid spawn position
      let x = 0;
      let y = 0;
      let attempts = 0;
      const maxAttempts = 10;

      while (attempts < maxAttempts) {
        x = 100 + Math.random() * 600;
        y = 100 + Math.random() * 400;

        // Check distance from all players
        let validPosition = true;
        room.state.players.forEach((player) => {
          const dx = x - player.x;
          const dy = y - player.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < MIN_SPAWN_DISTANCE) {
            validPosition = false;
          }
        });

        if (validPosition) break;
        attempts++;
      }

      // Create ECS entity
      const eid = addEntity(world);

      // Add components
      addComponent(world, Position, eid);
      Position.x[eid] = x;
      Position.y[eid] = y;

      addComponent(world, Velocity, eid);
      Velocity.x[eid] = 0;
      Velocity.y[eid] = 0;

      addComponent(world, Health, eid);
      Health.current[eid] = config.health;
      Health.max[eid] = config.health;

      addComponent(world, Enemy, eid);
      
      addComponent(world, Target, eid);
      Target.eid[eid] = 0; // No initial target

      addComponent(world, Combat, eid);
      Combat.attack[eid] = config.attack;
      Combat.strength[eid] = config.strength;
      Combat.defence[eid] = config.defence;
      Combat.attackSpeed[eid] = config.attackSpeed;
      Combat.lastAttackTime[eid] = 0;

      // Create and sync schema
      const enemySchema = new EnemySchema();
      enemySchema.id = `enemy_${eid}`;
      enemySchema.ecsId = eid;
      enemySchema.x = Position.x[eid];
      enemySchema.y = Position.y[eid];
      enemySchema.health = Health.current[eid];
      enemySchema.maxHealth = Health.max[eid];
      enemySchema.enemyType = enemyType;
      enemySchema.combatLevel = config.combatLevel;

      room.state.enemies.set(enemySchema.id, enemySchema);

      // Broadcast spawn event
      room.broadcast("enemySpawned", {
        id: enemySchema.id,
        type: enemyType,
        x: x,
        y: y,
      });
    }

    return world;
  });
};
````

### [GameState.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/shared/src/schemas/GameState.ts)

Add the EnemySchema and update GameRoomState:

````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
import { Schema, type, MapSchema } from "@colyseus/schema";

// ...existing code...

export class EnemySchema extends Schema {
  @type("string") id: string = "";
  @type("number") ecsId: number = 0;
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 0;
  @type("number") maxHealth: number = 0;
  @type("string") enemyType: string = "goblin"; // goblin, spider, orc, etc.
  @type("number") combatLevel: number = 2;
}

export class GameRoomState extends Schema {
  @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
  @type({ map: EnemySchema }) enemies = new MapSchema<EnemySchema>();
  @type("number") waveNumber: number = 0;
  @type("number") enemiesRemaining: number = 0;
}
````

### [GameRoom.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/game-server/src/rooms/GameRoom.ts)

Update GameRoom to properly handle entity death and integrate the new systems:

````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
````typescript
// ...existing code...
import { createEnemySpawnSystem } from "../ecs/systems/EnemySpawnSystem";
import { CombatWorld } from "../ecs/systems/CombatSystem";
import { removeEntity } from "bitecs";

// ...existing code...

export class GameRoom extends Room<GameRoomState> {
  private world!: CombatWorld;
  // ...existing code...

  onCreate(options: any) {
    // ...existing code...
    
    // Initialize world with room reference
    this.world = createWorld() as CombatWorld;
    this.world.room = this;
    this.world.entitiesToRemove = new Set();

    // Initialize systems (including new ones)
    this.systems = [
      createMovementSystem(),
      createCombatSystem(this),
      createTargetingSystem(),
      createEnemySpawnSystem(this),
      createStateUpdateSystem(this),
    ];

    // ...existing code...
    
    // Update simulation interval to handle entity death
    this.setSimulationInterval(() => {
      for (const system of this.systems) {
        system(this.world);
      }
      this.handleEntityDeath();
    });
  }

  /**
   * Handle entity death and cleanup
   */
  private handleEntityDeath(): void {
    if (!this.world.entitiesToRemove || this.world.entitiesToRemove.size === 0) {
      return;
    }

    for (const eid of this.world.entitiesToRemove) {
      // Find if it's a player or enemy
      let found = false;

      // Check players
      this.state.players.forEach((player, sessionId) => {
        if (player.ecsId === eid) {
          found = true;
          // Handle player death
          this.broadcast("playerDeath", { 
            playerId: sessionId,
            killer: "enemy" // TODO: Track actual killer
          });
          
          // Respawn the player
          Health.current[eid] = Health.max[eid];
          Position.x[eid] = 400; // Spawn position
          Position.y[eid] = 300;
          
          // Update state
          player.health = Health.current[eid];
          player.x = Position.x[eid];
          player.y = Position.y[eid];
        }
      });

      // Check enemies
      this.state.enemies.forEach((enemy, enemyId) => {
        if (enemy.ecsId === eid) {
          found = true;
          // Handle enemy death
          this.broadcast("enemyDeath", { 
            enemyId,
            type: enemy.enemyType,
            x: enemy.x,
            y: enemy.y
          });
          
          // Remove from state
          this.state.enemies.delete(enemyId);
          
          // Remove from ECS
          removeEntity(this.world, eid);
          
          // Update remaining count
          if (this.state.enemiesRemaining > 0) {
            this.state.enemiesRemaining--;
          }
        }
      });

      if (!found) {
        console.warn(`Entity ${eid} marked for removal but not found in state`);
        // Remove anyway to prevent memory leak
        removeEntity(this.world, eid);
      }
    }

    // Clear the set
    this.world.entitiesToRemove.clear();
  }

  // ...existing code...
}
````

### [GameScene.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/phaser-client/src/scenes/GameScene.ts)

Update the

---

