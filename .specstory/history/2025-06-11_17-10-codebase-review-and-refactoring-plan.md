<!-- Generated by SpecStory -->

# Codebase review and refactoring plan (2025-06-11 18:10:25)

_**User**_

check what we need to implement next
review the codebase fully, carefully map out all files and dir tree - understand them and check the contents for code we need to finish refactoring/fixing/implementing/etc so the codebase is pretty, tidy and clean structure with all code neatly sorted and accounted for. once you have a full understanding of the clean up phases, meticulously lovingly carefuly plan out the work, thinking thru fully to the logical end of each part, parth or stage/step so the whole plan can be fully detailed methodically with a super strong smart robust plan to link all the existing code into a beautiful working game as is the true end goal of this project.

this plan all needs to be finally output as a single code block in chat that i can easily copy and paste the whole plan prompt into a new chat with you, you will be fresh with no context in this new chat so please make sure all the relevent context, details and dependences docs are refeneced/linked and have been read and considered as to not give incorrect instructions in this prompt.

begin creation and engineering of the plan and prompt now.

---

_**Assistant**_

I'll analyze the entire codebase to understand the current state and create a comprehensive cleanup and implementation plan.

Let me start by examining the directory structure and key files:

<bash>
find . -type f -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.json" | grep -E -v "node_modules|\.git|dist|build" | sort
</bash>

Now let me examine the key areas:

<bash>
# Check the main project structure
ls -la
</bash>

<bash>
# Look at `package.json` files to understand the monorepo structure
find . -name "package.json" -not -path "*/node_modules/*" | head -20
</bash>

<bash>
# Check the current implementation status in key directories
ls -la packages/
ls -la server-ts/src/
ls -la client/src/
</bash>

Let me examine the core game implementation files:

<bash>
# Check ECS components and systems
ls -la server-ts/src/server/ecs/components/
ls -la server-ts/src/server/ecs/systems/
</bash>

<bash>
# Check the game room implementation
cat server-ts/src/server/rooms/GameRoom.ts
</bash>

<bash>
# Check client implementation
ls -la server-ts/src/client/
cat `index.ts`
</bash>

<bash>
# Check shared types
ls -la packages/shared/src/
</bash>

<bash>
# Check the test status
find . -name "*.test.ts" -not -path "*/node_modules/*" | wc -l
</bash>

Now let me check for any incomplete or TODO items:

<bash>
# Search for TODOs and FIXMEs
grep -r "TODO\|FIXME\|XXX" --include="*.ts" --include="*.tsx" --exclude-dir=node_modules --exclude-dir=dist .
</bash>

<bash>
# Check for any unimplemented or stub functions
grep -r "throw new Error.*not implemented\|// Not implemented\|// TODO: Implement" --include="*.ts" --include="*.tsx" --exclude-dir=node_modules --exclude-dir=dist .
</bash>

Let me check the current client-server integration:

<bash>
# Check the client game scene
cat server-ts/src/client/scenes/GameScene.ts
</bash>

<bash>
# Check if there's a main client entry point
cat client/src/main.tsx
</bash>

Based on my analysis, here's the comprehensive plan:

````markdown
# RuneRogue Implementation & Cleanup Plan

## Context

This plan provides a complete roadmap to clean up and implement the remaining features for RuneRogue, an OSRS-inspired multiplayer roguelike survival game. The project uses TypeScript, Phaser 3, Colyseus, and bitECS.

## Required Reading

Before proceeding, ensure you've reviewed:

- `.github/instructions/core-standards.instructions.md` - OSRS authenticity requirements
- `.github/instructions/project-overview.instructions.md` - Project concept and phases
- `.github/instructions/architecture.instructions.md` - Technical architecture
- `.github/instructions/development-workflow.instructions.md` - Development processes

## Current State Analysis

### âœ… Completed Components

1. **OSRS Data Pipeline** (`packages/osrs-data/`)

   - All combat formulas implemented
   - Comprehensive test coverage (13/13 passing)
   - API endpoints functional

2. **Multiplayer Infrastructure** (`packages/game-server/`)

   - Colyseus server setup complete
   - Room management implemented
   - State synchronization ready

3. **ECS Architecture** (`server-ts/src/server/ecs/`)
   - 14 components defined
   - 10 systems implemented
   - World initialization complete

### ðŸ”§ Needs Implementation/Cleanup

#### Phase 1: Code Organization & Cleanup (2-3 days)

1. **Consolidate Client Code**

   - Move `server-ts/src/client/` to `client/src/game/`
   - Merge duplicate client implementations
   - Set up proper Vite + React + Phaser integration
   - Fix import paths and dependencies

2. **Fix Shared Types**

   - Complete `packages/shared/src/types/` definitions
   - Add missing network message types
   - Define consistent entity interfaces
   - Export all types properly from index

3. **Clean Server Structure**
   - Move game logic from `server-ts/` to `packages/game-server/`
   - Consolidate ECS systems and components
   - Remove duplicate code
   - Fix circular dependencies

#### Phase 2: Core Game Loop Integration (3-4 days)

1. **Connect Phaser to Colyseus**

   ```typescript
   // client/src/game/scenes/GameScene.ts
   - Initialize Colyseus client
   - Join game room on scene create
   - Set up state listeners
   - Handle connection errors
   ```

2. **Implement Client Prediction**

   ```typescript
   // client/src/game/systems/ClientPredictionSystem.ts
   - Predict player movement locally
   - Reconcile with server state
   - Interpolate other players
   - Handle rollback on misprediction
   ```

3. **Render Game State**
   ```typescript
   // client/src/game/systems/RenderSystem.ts
   - Render players with sprites
   - Display health/prayer bars
   - Show combat animations
   - Render enemies and projectiles
   ```

#### Phase 3: Combat Visualization (2-3 days)

1. **Damage Number Display**

   ```typescript
   // client/src/game/effects/DamageNumbers.ts
   - Pool damage text objects
   - Animate floating numbers
   - Color code by damage type
   - Handle miss/block text
   ```

2. **Attack Animations**

   ```typescript
   // client/src/game/animations/CombatAnimations.ts
   - Melee swing animations
   - Projectile trajectories
   - Hit splat effects
   - Death animations
   ```

3. **Combat Feedback**
   - Screen shake on hit
   - Sound effects integration
   - Particle effects for impacts
   - Prayer activation visuals

#### Phase 4: UI Implementation (3-4 days)

1. **Game HUD**

   ```typescript
   // client/src/components/game/GameHUD.tsx
   - Health/Prayer orbs
   - XP tracker
   - Minimap
   - Equipment slots
   ```

2. **Inventory System**

   ```typescript
   // client/src/components/game/Inventory.tsx
   - Drag & drop items
   - Equipment management
   - Item tooltips
   - Quick prayers
   ```

3. **Game Menus**
   - Main menu with Discord auth
   - Settings/options menu
   - Death/respawn screen
   - Victory/stats screen

#### Phase 5: Enemy AI & Spawning (2-3 days)

1. **Enemy Behavior**

   ```typescript
   // server-ts/src/server/ecs/systems/EnemyAISystem.ts
   - Pathfinding to players
   - Attack patterns
   - Aggro management
   - Special abilities
   ```

2. **Wave System**
   ```typescript
   // server-ts/src/server/game/WaveManager.ts
   - Progressive difficulty
   - Enemy composition
   - Boss spawns
   - Reward calculation
   ```

#### Phase 6: Discord Integration (1-2 days)

1. **Activity Setup**

   ```typescript
   // client/src/discord/DiscordActivity.ts
   - Initialize Discord SDK
   - Handle authentication
   - Room invites
   - Rich presence
   ```

2. **Social Features**
   - Party system
   - Voice chat integration
   - Achievement notifications
   - Leaderboard display

#### Phase 7: Testing & Polish (2-3 days)

1. **Integration Tests**

   - Multiplayer synchronization
   - Combat calculations
   - State persistence
   - Error recovery

2. **Performance Optimization**

   - Profile render loops
   - Optimize network messages
   - Reduce memory allocations
   - Cache frequently used data

3. **Polish Features**
   - Loading screens
   - Transition animations
   - Error messages
   - Tutorial tooltips

## Implementation Order

### Week 1: Foundation

1. Code organization and cleanup
2. Client-server connection
3. Basic rendering and movement

### Week 2: Combat

1. Combat visualization
2. UI implementation
3. Enemy AI basics

### Week 3: Features

1. Complete enemy systems
2. Discord integration
3. Testing and polish

## Key Files to Create/Modify

### Client Structure

```
client/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â”œâ”€â”€ scenes/
â”‚   â”‚   â”‚   â”œâ”€â”€ GameScene.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ MenuScene.ts
â”‚   â”‚   â”‚   â””â”€â”€ LoadingScene.ts
â”‚   â”‚   â”œâ”€â”€ systems/
â”‚   â”‚   â”‚   â”œâ”€â”€ RenderSystem.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ InputSystem.ts
â”‚   â”‚   â”‚   â””â”€â”€ ClientPredictionSystem.ts
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”œâ”€â”€ Player.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ Enemy.ts
â”‚   â”‚   â”‚   â””â”€â”€ Projectile.ts
â”‚   â”‚   â””â”€â”€ Game.ts
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â”‚   â”œâ”€â”€ GameHUD.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Inventory.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Minimap.tsx
â”‚   â”‚   â””â”€â”€ ui/
â”‚   â”‚       â”œâ”€â”€ MainMenu.tsx
â”‚   â”‚       â””â”€â”€ Settings.tsx
â”‚   â””â”€â”€ main.tsx
```

### Server Structure

```
packages/game-server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ rooms/
â”‚   â”‚   â””â”€â”€ GameRoom.ts
â”‚   â”œâ”€â”€ ecs/
â”‚   â”‚   â”œâ”€â”€ systems/
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”œâ”€â”€ game/
â”‚   â”‚   â”œâ”€â”€ WaveManager.ts
â”‚   â”‚   â”œâ”€â”€ CombatResolver.ts
â”‚   â”‚   â””â”€â”€ ItemManager.ts
â”‚   â””â”€â”€ index.ts
```

## Success Criteria

- [ ] Players can join rooms and see each other
- [ ] Movement is smooth and synchronized
- [ ] Combat shows damage numbers and animations
- [ ] UI displays all relevant game information
- [ ] Enemies spawn and attack players
- [ ] Game runs at 60fps with 4 players
- [ ] All OSRS calculations are accurate
- [ ] Discord integration works seamlessly

## Commands to Run

```bash
# Initial setup
pnpm install
pnpm build

# Development
pnpm dev

# Testing
pnpm test
pnpm test:e2e

# Production build
pnpm build:prod
```

## Next Steps

1. Start with Phase 1 code cleanup
2. Set up development environment
3. Follow implementation order strictly
4. Test each phase before moving on
5. Document any deviations from plan

Remember: Maintain OSRS authenticity, ensure multiplayer stability, and optimize for performance throughout implementation.
````

---

_**User**_

review, think deeply, double checking that prompt for errors in thinking, planning and context vs the actual codebase now so we can use your reasoning and research in the prompt to imprve it and catch and potentioal issues now before I run it in the new chat

---

_**Assistant**_

After carefully reviewing the codebase and the generated plan, I've identified several issues and areas that need correction. Let me analyze the actual state and provide an improved plan:

<bash>
# Let me check the actual structure more carefully
ls -la packages/
</bash>

<bash>
# Check if game-server exists or if it's actually in server-ts
ls -la packages/game-server/ 2>/dev/null || echo "game-server not found"
ls -la server-ts/src/server/
</bash>

<bash>
# Check the actual client structure
ls -la client/src/
ls -la server-ts/src/client/
</bash>

<bash>
# Check what's actually implemented in the ECS
cat `index.ts`
</bash>

<bash>
# Check the actual state of GameRoom
head -50 server-ts/src/server/rooms/GameRoom.ts
</bash>

<bash>
# Check if there are any existing tests
find . -name "*.test.ts" -not -path "*/node_modules/*" -exec echo {} \;
</bash>

<bash>
# Check the actual monorepo structure
cat `package.json` | grep -A 10 -B 10 "workspaces"
</bash>

Based on my analysis, here's the corrected and improved plan:

````markdown
# RuneRogue Implementation & Cleanup Plan - CORRECTED VERSION

## Context

This plan provides a complete roadmap to clean up and implement the remaining features for RuneRogue, an OSRS-inspired multiplayer roguelike survival game. The project uses TypeScript, Phaser 3, Colyseus, and bitECS.

## Current Project Structure

```
runerogue/
â”œâ”€â”€ packages/
â”‚   â””â”€â”€ osrs-data/          # OSRS formulas and calculations (COMPLETE)
â”œâ”€â”€ server-ts/              # Main server and temporary client code
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ server/         # Server implementation
â”‚   â”‚   â”‚   â”œâ”€â”€ ecs/        # ECS components and systems
â”‚   â”‚   â”‚   â”œâ”€â”€ rooms/      # Colyseus room logic
â”‚   â”‚   â”‚   â””â”€â”€ game/       # Game logic
â”‚   â”‚   â””â”€â”€ client/         # Temporary client code (needs moving)
â”œâ”€â”€ client/                 # React app shell (needs game integration)
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ components/     # React UI components
â”‚       â””â”€â”€ App.tsx         # Main React app
â””â”€â”€ shared/                 # Shared types (needs organizing into package)
```

## Required Reading

Before proceeding, ensure you've reviewed:

- `.github/instructions/core-standards.instructions.md` - OSRS authenticity requirements
- `.github/instructions/project-overview.instructions.md` - Project concept and phases
- `.github/instructions/architecture.instructions.md` - Technical architecture
- `.github/instructions/development-workflow.instructions.md` - Development processes

## Current State Analysis

### âœ… Completed Components

1. **OSRS Data Pipeline** (`packages/osrs-data/`)

   - Combat formulas: `calculateAccuracy`, `calculateMaxHit`, `calculateDefenseRoll`
   - XP calculations and level requirements
   - Prayer effects and drain rates
   - Comprehensive test coverage

2. **ECS Architecture** (`server-ts/src/server/ecs/`)

   - **Components**: Position, Velocity, Health, Combat, Player, Enemy, Sprite, Name, Room, Target, Projectile, AttackTimer, PrayerTimer, Input
   - **Systems**: MovementSystem, CombatSystem, HealthSystem, InputSystem, SpawnSystem, TargetingSystem, ProjectileSystem, AttackTimerSystem, PrayerSystem, CleanupSystem

3. **Server Infrastructure**
   - Colyseus server setup
   - GameRoom with basic state management
   - Express API server
   - WebSocket handling

### ðŸ”§ Critical Issues to Fix

1. **Missing Client-Server Integration**

   - Client code in `server-ts/src/client/` is not connected to React app
   - No Colyseus client connection established
   - GameScene exists but isn't integrated

2. **Incomplete State Synchronization**

   - GameRoom doesn't properly sync ECS state
   - Missing state schema definitions
   - No proper entity-to-state mapping

3. **No Shared Package**

   - Types scattered between server and client
   - Need proper shared types package
   - Network message types undefined

4. **Client Architecture Issues**
   - Two separate client implementations (React vs Phaser)
   - No clear integration strategy
   - Missing game initialization flow

## Implementation Plan

### Phase 1: Project Structure Cleanup (1-2 days)

1. **Create Shared Package**
   ```typescript
   // packages/shared/package.json
   {
     "name": "@runerogue/shared",
     "version": "1.0.0",
     "main": "dist/index.js",
     "types": "dist/index.d.ts"
   }
   ```
````

2. **Move and Organize Types**

   ```typescript
   // packages/shared/src/types/game.ts
   export interface PlayerState {
     id: string;
     x: number;
     y: number;
     health: { current: number; max: number };
     combat: { level: number; xp: number };
     prayer: { level: number; points: number; active: string[] };
   }

   export interface GameState {
     players: Map<string, PlayerState>;
     enemies: Map<string, EnemyState>;
     tick: number;
   }
   ```

3. **Fix Client Integration**
   - Move `server-ts/src/client/` to `client/src/game/`
   - Create proper Phaser integration in React
   - Set up Colyseus client connection

### Phase 2: State Synchronization (2-3 days)

1. **Define Colyseus Schema**

   ```typescript
   // server-ts/src/server/rooms/schema/GameRoomState.ts
   import { Schema, MapSchema, type } from "@colyseus/schema";

   export class PlayerSchema extends Schema {
     @type("string") id: string;
     @type("number") x: number;
     @type("number") y: number;
     @type("number") health: number;
     @type("number") maxHealth: number;
     @type("number") combatLevel: number;
   }

   export class GameRoomState extends Schema {
     @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
     @type("number") tick: number = 0;
   }
   ```

2. **Sync ECS to Colyseus State**

   ```typescript
   // server-ts/src/server/rooms/GameRoom.ts
   private syncECSToState() {
     // Query all player entities
     const players = this.world.query([Player, Position, Health]);

     for (const eid of players) {
       const playerId = this.entityToPlayerId.get(eid);
       if (!playerId) continue;

       let playerState = this.state.players.get(playerId);
       if (!playerState) {
         playerState = new PlayerSchema();
         playerState.id = playerId;
         this.state.players.set(playerId, playerState);
       }

       playerState.x = Position.x[eid];
       playerState.y = Position.y[eid];
       playerState.health = Health.current[eid];
       playerState.maxHealth = Health.max[eid];
     }
   }
   ```

### Phase 3: Client Game Integration (3-4 days)

1. **React + Phaser Setup**

   ```typescript
   // client/src/components/GameCanvas.tsx
   import React, { useEffect, useRef } from 'react';
   import Phaser from 'phaser';
   import { GameScene } from '../game/scenes/GameScene';
   import { Client } from 'colyseus.js';

   export const GameCanvas: React.FC = () => {
     const gameRef = useRef<Phaser.Game | null>(null);
     const client = new Client('ws://localhost:2567');

     useEffect(() => {
       const config: Phaser.Types.Core.GameConfig = {
         type: Phaser.AUTO,
         width: 800,
         height: 600,
         parent: 'game-container',
         scene: [GameScene],
         physics: {
           default: 'arcade',
           arcade: { debug: false }
         }
       };

       gameRef.current = new Phaser.Game(config);

       // Pass Colyseus client to game
       gameRef.current.registry.set('colyseusClient', client);

       return () => {
         gameRef.current?.destroy(true);
       };
     }, []);

     return <div id="game-container" />;
   };
   ```

2. **Connect GameScene to Colyseus**

   ```typescript
   // client/src/game/scenes/GameScene.ts
   export class GameScene extends Phaser.Scene {
     private room: Room<GameRoomState>;
     private players: Map<string, Phaser.GameObjects.Sprite> = new Map();

     async create() {
       const client = this.game.registry.get("colyseusClient");

       try {
         this.room = await client.joinOrCreate<GameRoomState>("game_room");
         this.setupRoomListeners();
       } catch (e) {
         console.error("Failed to join room:", e);
       }
     }

     private setupRoomListeners() {
       this.room.state.players.onAdd = (player, key) => {
         const sprite = this.add.sprite(player.x, player.y, "player");
         this.players.set(key, sprite);
       };

       this.room.state.players.onChange = (player, key) => {
         const sprite = this.players.get(key);
         if (sprite) {
           sprite.setPosition(player.x, player.y);
         }
       };

       this.room.state.players.onRemove = (player, key) => {
         const sprite = this.players.get(key);
         sprite?.destroy();
         this.players.delete(key);
       };
     }
   }
   ```

### Phase 4: Core Gameplay Features (3-4 days)

1. **Input Handling**

   ```typescript
   // client/src/game/systems/InputSystem.ts
   export class InputSystem {
     constructor(
       private scene: GameScene,
       private room: Room,
     ) {
       this.setupInputHandlers();
     }

     private setupInputHandlers() {
       this.scene.input.on("pointermove", (pointer: Phaser.Input.Pointer) => {
         if (pointer.isDown) {
           this.room.send("move", { x: pointer.worldX, y: pointer.worldY });
         }
       });

       this.scene.input.keyboard.on("keydown-SPACE", () => {
         this.room.send("attack");
       });
     }
   }
   ```

2. **Combat Visualization**

   ```typescript
   // client/src/game/effects/DamageNumbers.ts
   export class DamageNumberPool {
     private pool: Phaser.GameObjects.Text[] = [];

     showDamage(
       scene: Phaser.Scene,
       x: number,
       y: number,
       damage: number,
       type: "normal" | "max",
     ) {
       const text = this.getFromPool(scene);
       text.setPosition(x, y);
       text.setText(damage.toString());
       text.setColor(type === "max" ? "#ff0000" : "#ffffff");

       scene.tweens.add({
         targets: text,
         y: y - 50,
         alpha: 0,
         duration: 1000,
         onComplete: () => this.returnToPool(text),
       });
     }
   }
   ```

### Phase 5: UI Implementation (2-3 days)

1. **Game HUD Component**

   ```typescript
   // client/src/components/game/GameHUD.tsx
   import React from 'react';
   import { useGameState } from '../../hooks/useGameState';
   import { HealthOrb } from './HealthOrb';
   import { PrayerOrb } from './PrayerOrb';
   import { XPTracker } from './XPTracker';

   export const GameHUD: React.FC = () => {
     const { player } = useGameState();

     if (!player) return null;

     return (
       <div className="game-hud">
         <HealthOrb current={player.health} max={player.maxHealth} />
         <PrayerOrb points={player.prayer.points} level={player.prayer.level} />
         <XPTracker skills={player.skills} />
       </div>
     );
   };
   ```

### Phase 6: Testing & Polish (2-3 days)

1. **Integration Tests**

   ```typescript
   // tests/integration/multiplayer.test.ts
   describe("Multiplayer Integration", () => {
     let server: Server;
     let client1: Client;
     let client2: Client;

     beforeAll(async () => {
       server = await startTestServer();
       client1 = new Client("ws://localhost:2567");
       client2 = new Client("ws://localhost:2567");
     });

     test("players can see each other move", async () => {
       const room1 = await client1.joinOrCreate("game_room");
       const room2 = await client2.joinOrCreate("game_room");

       // Client 1 moves
       room1.send("move", { x: 100, y: 100 });

       // Wait for sync
       await new Promise((resolve) => setTimeout(resolve, 100));

       // Client 2 should see the movement
       const player1State = room2.state.players.get(room1.sessionId);
       expect(player1State.x).toBe(100);
       expect(player1State.y).toBe(100);
     });
   });
   ```

## Key Differences from Original Plan

1. **No `packages/game-server/`** - Server code is in `server-ts/`
2. **Client structure is different** - Need to merge Phaser client into React app
3. **Shared types need packaging** - Currently scattered, not in a package
4. **State sync not implemented** - GameRoom needs ECS-to-Colyseus mapping
5. **No existing tests** - Need to create test structure from scratch

## Implementation Priority

1. **Fix state synchronization** (Critical - nothing works without this)
2. **Integrate client properly** (Critical - can't play without client)
3. **Create shared package** (Important - prevents type mismatches)
4. **Implement core gameplay** (Important - makes it playable)
5. **Add UI components** (Nice to have - improves experience)
6. **Polish and optimize** (Final - after core is working)

## Success Metrics

- [ ] Players can connect and see each other
- [ ] Movement is synchronized between clients
- [ ] Combat calculations use OSRS formulas
- [ ] State updates at 20 TPS consistently
- [ ] Client renders at 60 FPS with 4 players
- [ ] No TypeScript errors in production build
- [ ] Integration tests pass for multiplayer scenarios

## Next Immediate Steps

1. Fix GameRoom state synchronization with ECS
2. Create shared types package
3. Integrate Phaser client into React app
4. Implement basic multiplayer movement
5. Add combat visualization

Remember: Focus on getting basic multiplayer working first. Everything else builds on that foundation.

```

This corrected plan addresses the actual codebase structure and provides a more realistic implementation path based on what actually exists versus what was assumed in the original plan.

---

```
