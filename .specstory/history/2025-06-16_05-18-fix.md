<!-- Generated by SpecStory -->

# /fix (2025-06-16 06:18:24)

_**User**_

/fix

---

_**Assistant**_

Looking at the core-standards.instructions.md file, I can see there are no syntax errors or problems with the markdown itself. However, I'll enhance it to make it more comprehensive and actionable based on the architecture overview and current project status.

## Solution Steps

1. Add specific implementation guidelines for ECS architecture
2. Include concrete examples for OSRS authenticity validation
3. Add performance benchmarking requirements
4. Enhance error handling patterns with specific examples
5. Add deployment and CI/CD standards

### [core-standards.instructions.md](file:///c%3A/Users/aggis/GitHub/runerogue/.github/instructions/core-standards.instructions.md)

Enhanced core standards with specific implementation guidelines, concrete examples, and additional sections for ECS patterns, performance benchmarking, and deployment standards.

````markdown
---
applyTo: "**"
---

# RuneRogue Core Development Instructions

## OSRS Authenticity Requirements

**CRITICAL**: All game mechanics must exactly match Old School RuneScape. No approximations or shortcuts.

### Combat Calculations

- Use exact OSRS damage formulas from `packages/osrs-data/`
- Attack speed must be precise: 4-tick (2.4s), 5-tick (3.0s), 6-tick (3.6s)
- Combat level calculation must match OSRS Wiki exactly
- Prayer effects and drain rates must be authentic

#### Example Validation

```typescript
// Always validate against known OSRS values
const expectedMaxHit = 15; // From OSRS Wiki for specific gear
const calculatedMaxHit = CombatCalculator.calculateMaxHit(playerStats);
expect(calculatedMaxHit).toBe(expectedMaxHit);
```

### Data Validation

- Cross-reference all stats with OSRS Wiki
- Use existing OSRS data pipeline for validation
- Test calculations against known OSRS values
- Document Wiki sources in code comments

## TypeScript Standards

### Type Safety

- Use strict TypeScript settings, no `any` types
- Define proper interfaces for all game data structures
- Add comprehensive JSDoc documentation
- Implement proper error handling with Result types

#### Example Result Type Pattern

```typescript
type Result<T, E = Error> =
  | { success: true; value: T }
  | { success: false; error: E };

function calculateDamage(
  attacker: CombatStats,
  defender: CombatStats,
): Result<number> {
  try {
    const damage = CombatCalculator.calculateDamage(attacker, defender);
    return { success: true, value: damage };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

### Performance Requirements

- Target 60fps with 4+ players
- Use object pools for frequently created objects
- Optimize ECS queries and systems
- Profile hot code paths regularly
- Maximum 16ms per frame budget

## Architecture Patterns

### ECS (Entity Component System) Design

- **Components**: Data-only structures, no logic
- **Systems**: Pure functions that operate on components
- **Queries**: Cached and optimized for performance
- **Entity Lifecycle**: Proper creation and destruction

#### Example ECS Pattern

```typescript
// Component - data only
interface PositionComponent {
  x: number;
  y: number;
}

// System - logic only
export class MovementSystem {
  update(entities: Entity[], deltaTime: number): void {
    const query = this.world.query([PositionComponent, VelocityComponent]);
    for (const entity of query) {
      const pos = entity.get(PositionComponent);
      const vel = entity.get(VelocityComponent);
      pos.x += vel.x * deltaTime;
      pos.y += vel.y * deltaTime;
    }
  }
}
```

### Server Design

- **Colyseus Rooms**: Handle 2-4 player game sessions
- **Express APIs**: Serve OSRS data and static content
- **Schema-based State**: Use @colyseus/schema for synchronization
- **Modular Packages**: Separate concerns (osrs-data, game-server, shared)

### Client Architecture

- **Multiple Client Support**: Phaser web client + Godot native client
- **Real-time Sync**: WebSocket connection to Colyseus rooms
- ***
````
