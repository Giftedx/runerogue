<!-- Generated by SpecStory -->

# Excellent. The foundational client-side combat cal (2025-06-18 11:29:07)

_**User**_

Excellent. The foundational client-side combat calculation is in place. Now, we must evolve this into a complete, server-authoritative combat loop that adheres to the project's architectural principles and OSRS authenticity standards.

Here is the prompt for our next session. It outlines the critical steps to refactor the current implementation, move logic to the server, and add the necessary UI feedback for a polished player experience.

---

### RuneRogue Development Prompt

**Goal:** Refactor the existing client-side combat proof-of-concept into a complete, server-authoritative melee combat loop, including OSRS-accurate attack speed, server-side validation, and client-side visual feedback (damage splats).

**Current State Analysis:**
The current implementation successfully uses the `osrs-data` package to calculate damage within a client-side ECS. However, it has several critical limitations that deviate from the project architecture:

1.  **Client-Authoritative:** The client decides if an attack occurs and calculates the damage, which is a major security and state-synchronization issue.
2.  **No Attack Speed:** Attacks can be triggered on every frame by holding the spacebar, which does not respect OSRS tick-based weapon speeds.
3.  **No Server Sync:** The damage dealt is only visible in the client's console; it is not sent to the server or synchronized with other players.
4.  **No UI Feedback:** There are no visual indicators of combat (animations, damage numbers, etc.).

**Architectural Mandate (from documentation):**

- **Server Authority:** All game logic must be validated and executed on the server (game-server). The client sends intents (e.g., "I want to attack this target"), and the server processes the outcome.
- **OSRS Authenticity:** Combat mechanics, especially attack speed (e.g., 4 ticks for a scimitar), must be precisely implemented.
- **ECS Design:** Logic should remain in systems, operating on data-only components.

---

### **Phase 1: Server-Side Combat Logic**

The server must be the single source of truth for all combat events.

**Tasks:**

1.  **Create `Attack` Message Handler:** In RuneRogueRoom.ts, create a new message handler for `room.onMessage("attack", ...)`. This handler will receive the target's entity ID from the client.
2.  **Implement Server-Side Combat System:** Create a new ECS system within the `game-server` that:
    - Receives the attack request from the message handler.
    - Validates the request (e.g., Is the attacker in range? Is the attacker's weapon off cooldown?).
    - Uses the existing `calculateAccuracy` and `calculateMaxHit` functions from `@runerogue/osrs-data` to determine the outcome.
    - Applies the damage to the target's `health` component in the server's authoritative state.
3.  **Implement Attack Speed (Cooldown):** Add a `lastAttackTick` component or similar mechanism to the player's state on the server. The server must reject attack requests that arrive before the player's weapon cooldown (e.g., 4 ticks \* 600ms) has passed.
4.  **Update `Player` and `Enemy` Schemas:** Ensure the schemas in `packages/game-server/src/rooms/schema/RuneRogueState.ts` contain all necessary combat stats (`attack`, `strength`, `defence`, `health`, `maxHealth`) to be synchronized with the client.

---

### **Phase 2: Client-Side Refactoring**

The client must be refactored to send attack intents and render the results from the server, not calculate them.

**Tasks:**

1.  **Send Attack Message:** Modify the input handler in GameScene.ts. Instead of adding a `MeleeAttack` component locally, it should now call `this.room.send("attack", { targetId: ... })`.
2.  **Implement Client-Side Cooldown:** To prevent spamming the server, add a client-side check to ensure an attack message can only be sent when the weapon is off cooldown. This provides a responsive user experience while the server provides the final validation.
3.  **Remove Client-Side Combat Calculation:** The `meleeCombatSystem` in the `phaser-client` should be removed or repurposed. Its responsibility for calculating damage is now deprecated.

---

### **Phase 3: UI/FX and Visual Feedback**

The player needs to see the results of combat.

**Tasks:**

1.  **Create Damage Splat System:** Create a new client-side ECS system (`damageSplatSystem.ts`).
    - This system will monitor the `Health` component of all entities.
    - When it detects a change in an entity's `Health.current` value, it will spawn a temporary "damage splat" (a rising text object with the damage amount) at the entity's position.
2.  **Create Health Bars:** Implement floating health bars above all entities (players and enemies) that have a `Health` component. The health bar should be a Phaser graphics object that visually represents `Health.current / Health.max`.
3.  **Update React UI:** Ensure the player's `HealthBar` in the React UI updates in real-time by listening to the Zustand store, which should be updated with the authoritative health value from the Colyseus room state.

**Acceptance Criteria:**

- Pressing the spacebar sends an "attack" message to the server, respecting a 4-tick (2.4s) cooldown on both the client and server.
- The server calculates the damage and updates the target's health in the `RuneRogueState`.
- All clients receive the health update, and the target entity's health bar changes.
- A red damage splat showing the damage dealt appears above the target on all clients.
- The client's local `meleeCombatSystem.ts` no longer calculates damage.

---

_**Assistant**_

I will find the relevant code for refactoring the combat system to be server-authoritative. Here is my plan:

1.  I will locate the core server-side files that will need to be changed, including `RuneRogueRoom.ts` and `RuneRogueState.ts`.
2.  Then, I will find the relevant combat calculation functions in the `osrs-data` package.
3.  Next, I will identify the client-side files for refactoring, such as `GameScene.ts` and the existing `meleeCombatSystem`.
4.  Finally, I will find the UI components related to health display, like the React `HealthBar` and the corresponding Zustand store.

This will provide a comprehensive set of files to begin the refactoring process. I will find the relevant code to help you refactor the combat system. Here is the context from the files you'll need to modify.

First, I'll locate the core server-side and client-side files mentioned in the prompt. This is a complex request that involves refactoring the combat loop from client-side to server-authoritative, touching multiple packages (`game-server`, `phaser-client`, `osrs-data`, `shared`). I will locate all the necessary files and code snippets to facilitate this task.

### Phase 1: Server-Side Combat Logic

First, I'll find the server-side files that need to be modified.

Hello! As a code search expert, I've analyzed your request to refactor the combat system. Here are the relevant files and code snippets from your workspace to help you with this task.

### 1. Server-Side Combat Logic

Here are the files for implementing the server-authoritative combat loop.

- **`RuneRogueRoom.ts`**: This is where you'll add the `onMessage("attack", ...)` handler.
  I will begin by exploring the core files on both the client and server that are mentioned in the prompt. This will help me gather the necessary context to understand the current combat implementation before the requested refactoring.

I'll start by reading the main server room logic, the client's main game scene, and the data file containing the OSRS combat formulas. I will also search for the client-side combat system, the server-side state schema, and any UI components related to health. Hello! As a code search expert, I've analyzed your request to refactor the combat system. To help you with this, I've gathered all the relevant files and context from the codebase. Here is a summary of the files that will be instrumental for your task, broken down by the phases you've outlined.

### **Phase 1: Server-Side Combat Logic**

This phase focuses on establishing the server as the authority for combat. The following files are key to implementing the attack message handler, server-side combat system, and updating the game state.

- **`packages/game-server/src/rooms/RuneRogueRoom.ts`**: This is the main room file where you'll add the `onMessage("attack", ...)` handler. It already contains a deprecated implementation of `handlePlayerAttack` and OSRS calculation methods which can serve as a reference.
- **`packages/game-server/src/schemas/GameState.ts`**: This file defines the server's authoritative state, including `Player` and `Enemy` schemas. You will need to ensure these schemas contain all the necessary combat-related stats (`attack`, `strength`, `defence`, `health`, `maxHealth`).
- **`packages/osrs-data/src/calculators/combat.ts`**: This file contains the canonical OSRS combat formulas (`calculateAccuracy`, `calculateMaxHit`) that your server-side combat system will use.

### **Phase 2: Client-Side Refactoring**

For this phase, you'll adjust the client to send attack "intents" to the server rather than handling combat logic itself.

- **`packages/phaser-client/src/scenes/GameScene.ts`**: You'll modify the input handler in this scene. The current implementation adds a `MeleeAttack` component; you will change it to send an "attack" message to the server.
- **`packages/phaser-client/src/ecs/systems/combat.ts`**: This is the client-side combat system that currently handles damage calculation. As per your instructions, this system will be deprecated or removed.
- **`packages/phaser-client/src/ecs/components.ts`**: This file defines the `MeleeAttack` and `Health` components used by the current client-side ECS. You'll be removing the logic that uses `MeleeAttack` and instead reacting to changes in the `Health` component from the server.

### **Phase 3: UI/FX and Visual Feedback**

To provide players with clear feedback, you'll implement health bars and damage splats.

- **`packages/phaser-client/src/ui/components/HealthBar.tsx`**: This is the React component for the player's health bar in the main UI.
- **`packages/phaser-client/src/stores/gameStore.ts`**: This Zustand store manages the UI state, including the player's health. It will need to be updated based on the authoritative state from the server to keep the `HealthBar` component in sync.

Below are the full contents of these files for your review.

### File Contents:

#### `packages/game-server/src/rooms/RuneRogueRoom.ts`

```typescript
/**
 * @deprecated LEGACY ROOM - This is a simplified, non-ECS prototype implementation.
 * It is kept for reference but is not part of the main game server.
 * The canonical, active room is 'RuneRogueGameRoom' in the '@runerogue/server' package, which uses the ECS architecture.
 *
 * RuneRogue Game Room
 * Main Colyseus room for RuneRogue multiplayer sessions
 *
 * @author agent/backend-infra (The Architect)
 */

import { Room, Client } from "colyseus";
import { GameState, Player, Enemy } from "../schemas/GameState";

export class RuneRogueRoom extends Room<GameState> {
  maxClients = 4; // Discord group limit
  private gameLoop?: NodeJS.Timeout;
  private readonly TICK_RATE = 50; // 20 TPS (50ms per tick)
  private readonly OSRS_WALK_SPEED = 1.67; // tiles per second (OSRS: 1 tile per 0.6s)
  private readonly SPAWN_INTERVAL = 5000; // 5 seconds between spawns

  /**
   * Calculate OSRS max hit formula
   */
  private calculateMaxHit(
    strength: number,
    strengthBonus: number = 0,
    prayerMultiplier: number = 1.0,
    styleBonus: number = 0
  ): number {
    const effectiveStrength =
      Math.floor(strength * prayerMultiplier) + styleBonus + 8;
    const maxHit = Math.floor(
      0.5 + (effectiveStrength * (strengthBonus + 64)) / 640
    );
    return maxHit;
  }

  /**
   * Calculate OSRS accuracy formula
   */
  private calculateAccuracy(
    attackerAttack: number,
    attackerEquipmentBonus: number = 0,
    defenderDefence: number,
    defenderEquipmentBonus: number = 0,
    prayerMultiplier: number = 1.0
  ): number {
    const effectiveAttack = Math.floor(attackerAttack * prayerMultiplier) + 8;
    const maxAttackRoll = effectiveAttack * (attackerEquipmentBonus + 64);

    const effectiveDefence = Math.floor(defenderDefence * prayerMultiplier) + 8;
    const maxDefenceRoll = effectiveDefence * (defenderEquipmentBonus + 64);

    if (maxAttackRoll > maxDefenceRoll) {
      return 1 - (maxDefenceRoll + 2) / (2 * (maxAttackRoll + 1));
    } else {
      return maxAttackRoll / (2 * (maxDefenceRoll + 1));
    }
  }

  onCreate(options: any) {
    this.setState(new GameState());

    console.log(
      `[${new Date().toISOString()}] RuneRogueRoom created with options:`,
      options
    );

    // Set up message handlers
    this.onMessage("move", this.handlePlayerMovement.bind(this));
    this.onMessage("attack", this.handlePlayerAttack.bind(this));
    this.onMessage("start_game", this.handleStartGame.bind(this));

    // Initialize game loop
    this.startGameLoop();
  }

  /**
   * Start the main game loop at 20 TPS
   */
  private startGameLoop() {
    this.gameLoop = setInterval(() => {
      this.updateGame();
    }, this.TICK_RATE);
  }

  /**
   * Main game update loop
   */
  private updateGame() {
    const now = Date.now();
    this.state.gameTime = now;

    if (!this.state.gameStarted) return;

    // Spawn enemies
    this.updateEnemySpawning(now);

    // Update combat
    this.updateCombat(now);

    // Cleanup dead enemies
    this.cleanupDeadEnemies();
  }
  /**
   * Handle player movement with server-side validation
   */
  private handlePlayerMovement(client: Client, data: { x: number; y: number }) {
    console.log(
      `🏃 handlePlayerMovement called: ${client.sessionId} -> (${data.x}, ${data.y})`
    );

    const player = this.state.players.get(client.sessionId);
    if (!player) {
      console.log(`❌ Player not found: ${client.sessionId}`);
      return;
    }
    const now = Date.now();
    const timeDelta = (now - player.lastMoveTime) / 1000; // seconds
    const distance = Math.abs(data.x - player.x) + Math.abs(data.y - player.y);

    // Allow first move or reasonable movement speeds
    // OSRS: ~1.67 tiles/second, but allow up to 3 tiles/second for responsiveness
    const maxDistance = Math.max(3, this.OSRS_WALK_SPEED * 2 * timeDelta);

    // Anti-cheat: Validate movement speed (only after first move)
    if (distance > maxDistance && player.lastMoveTime > 0 && timeDelta < 5) {
      console.log(
        `[ANTI-CHEAT] Player ${client.sessionId} rejected for speed: ${distance} > ${maxDistance} (timeDelta: ${timeDelta}s)`
      );
      client.send("movement_rejected", {
        reason: "too_fast",
        current: { x: player.x, y: player.y },
      });
      return;
    }

    // Update position
    player.x = data.x;
    player.y = data.y;
    player.lastMoveTime = now;

    console.log(`Player ${client.sessionId} moved to (${data.x}, ${data.y})`);
  }

  /**
   * Handle player attack command
   */
  private handlePlayerAttack(client: Client, data: { targetId: string }) {
    const player = this.state.players.get(client.sessionId);
    if (!player) return;

    const enemy = this.state.enemies.get(data.targetId);
    if (!enemy || !enemy.alive) return;

    const now = Date.now();
    const attackSpeed = 2400; // 4-tick (2.4s) - OSRS standard attack speed

    // Check attack cooldown
    if (now - player.lastAttackTime < attackSpeed) return;

    // Check range (simplified - within 2 tiles)
    const distance =
      Math.abs(player.x - enemy.x) + Math.abs(player.y - enemy.y);
    if (distance > 2) return;

    // Perform attack using OSRS calculations
    this.performAttack(player, enemy, now);
  }
  /**
   * Handle start game command
   */
  private handleStartGame(client: Client) {
    console.log(`🚀 handleStartGame called by: ${client.sessionId}`);

    if (this.state.gameStarted) {
      console.log(`⚠️ Game already started`);
      return;
    }

    this.state.gameStarted = true;
    this.state.lastSpawnTime = Date.now();

    console.log(`Game started by ${client.sessionId}`);
    this.broadcast("game_started", {});
  }

  onJoin(client: Client, options: any) {
    console.log(
      `[${new Date().toISOString()}] Player joined room '${this.roomId}' - Player ID: ${client.sessionId}`
    );

    // Create new player
    const player = new Player();
    player.id = client.sessionId;
    player.name = options.name || `Player${this.clients.length}`;
    player.x = Math.random() * 20; // Random spawn position
    player.y = Math.random() * 20;
    player.health = 10;
    player.maxHealth = 10;
    player.attackLevel = 1;
    player.strengthLevel = 1;
    player.defenceLevel = 1;
    player.hitpointsLevel = 10;
    player.prayerLevel = 1;
    player.prayerPoints = 1;
    player.lastMoveTime = Date.now();

    this.state.players.set(client.sessionId, player);

    // Send initial game data
    client.send("joined", {
      playerId: client.sessionId,
      gameState: {
        started: this.state.gameStarted,
        wave: this.state.waveNumber,
        enemies: this.state.enemiesKilled,
      },
    });

    console.log(
      `[${new Date().toISOString()}] Room '${this.roomId}' state - Players: ${this.clients.length}/${this.maxClients}`
    );
  }

  /**
   * Handles player disconnection with Colyseus reconnection support.
   * If a client disconnects, allowReconnection gives them 30 seconds to reconnect and reclaim their state.
   * If they reconnect within the window, their player state is preserved.
   * If not, their player is removed from the game state.
   *
   * @param client The Colyseus client that left
   * @param consented Whether the leave was voluntary
   */
  onLeave(client: Client, consented: boolean) {
    console.log(
      `[${new Date().toISOString()}] Player left room '${this.roomId}' - Player ID: ${client.sessionId} (consented: ${consented})`
    );

    // Colyseus reconnection support: allow player to reconnect for 30 seconds
    this.allowReconnection(client, 30).then(() => {
      // Reconnection succeeded, do nothing (player state is preserved)
      console.log(
        `[${new Date().toISOString()}] Player reconnected to room '${this.roomId}' - Player ID: ${client.sessionId}`
      );
    }).catch(() => {
      // Reconnection window expired, remove player
      this.state.players.delete(client.sessionId);
      console.log(
        `[${new Date().toISOString()}] Player permanently left room '${this.roomId}' - Player ID: ${client.sessionId}`
      );
      console.log(
        `[${new Date().toISOString()}] Room '${this.roomId}' state - Players: ${this.clients.length}/${this.maxClients}`
      );
    });
  }

  onDispose() {
    console.log(`[${new Date().toISOString()}] Room '${this.roomId}' disposed`);

    // Cleanup game loop
    if (this.gameLoop) {
      clearInterval(this.gameLoop);
    }
  }

  /**
   * Update enemy spawning system
   */
  private updateEnemySpawning(now: number) {
    if (now - this.state.lastSpawnTime < this.SPAWN_INTERVAL) return;

    const playerCount = this.state.players.size;
    if (playerCount === 0) return;

    const enemyCount = this.state.enemies.size;
    const maxEnemies = Math.min(20, playerCount * 5); // Scale with players

    if (enemyCount < maxEnemies) {
      this.spawnEnemy();
      this.state.lastSpawnTime = now;
    }
  }

  /**
   * Spawn a new enemy
   */
  private spawnEnemy() {
    const enemy = new Enemy();
    enemy.id = `enemy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    enemy.type = "goblin"; // Start with goblins
    enemy.x = Math.random() * 30; // Random position
    enemy.y = Math.random() * 30;
    enemy.health = 5;
    enemy.maxHealth = 5;
    enemy.attackLevel = 2;
    enemy.defenceLevel = 1;
    enemy.alive = true;
    enemy.lastAttackTime = 0;

    this.state.enemies.set(enemy.id, enemy);
    console.log(`Spawned ${enemy.type} at (${enemy.x}, ${enemy.y})`);
  }

  /**
   * Update combat system
   */
  private updateCombat(now: number) {
    // Auto-combat for players
    this.state.players.forEach((player) => {
      if (now - player.lastAttackTime >= 2400) {
        // 4-tick attack speed
        const nearestEnemy = this.findNearestEnemy(player.x, player.y);
        if (nearestEnemy && this.getDistance(player, nearestEnemy) <= 2) {
          this.performAttack(player, nearestEnemy, now);
        }
      }
    });

    // Simple enemy AI - attack nearest player
    this.state.enemies.forEach((enemy) => {
      if (!enemy.alive) return;

      if (now - enemy.lastAttackTime >= 3000) {
        // Slower enemy attacks
        const nearestPlayer = this.findNearestPlayer(enemy.x, enemy.y);
        if (nearestPlayer && this.getDistance(enemy, nearestPlayer) <= 2) {
          this.performEnemyAttack(enemy, nearestPlayer, now);
        }
      }
    });
  }
  /**
   * Perform attack using authentic OSRS combat calculations
   */ private performAttack(attacker: Player, target: Enemy, now: number) {
    try {
      // Calculate accuracy using OSRS formula
      const accuracy = this.calculateAccuracy(
        attacker.attackLevel,
        0, // No equipment bonus for now
        target.defenceLevel,
        0 // No equipment bonus for now
      );

      // Roll for hit success
      const hitSuccess = Math.random() < accuracy;

      let damage = 0;
      if (hitSuccess) {
        // Calculate max hit using OSRS formula
        const maxHit = this.calculateMaxHit(attacker.strengthLevel);

        // Roll damage between 1 and max hit
        damage = Math.floor(Math.random() * maxHit) + 1;
      }

      // Apply damage
      target.health = Math.max(0, target.health - damage);
      attacker.lastAttackTime = now;

      // Check if enemy died
      if (target.health <= 0) {
        target.alive = false;
        this.state.enemiesKilled++;

        // Award XP: 4 * damage dealt (OSRS formula)
        const xpGained = damage * 4;
        this.broadcast("enemy_killed", {
          enemyId: target.id,
          killerId: attacker.id,
          xpGained: xpGained,
          position: {
            x: target.x,
            y: target.y,
          },
          enemyType: target.type,
        });
      } // Broadcast enhanced combat visual event
      this.broadcast("damage_dealt", {
        attackerId: attacker.id,
        targetId: target.id,
        damage: damage,
        targetHealth: target.health,
        targetMaxHealth: target.maxHealth,
        hitSuccess: hitSuccess,
        accuracy: Math.round(accuracy * 100),
        effectType:
          hitSuccess ?
            damage > 0 ?
              "damage"
            : "zero"
          : "miss",
        position: {
          x: target.x,
          y: target.y,
        },
      });

      // Broadcast XP gain event for attacker
      if (hitSuccess && damage > 0) {
        const xpGained = damage * 4; // OSRS XP formula
        this.broadcast("xp_gained", {
          playerId: attacker.id,
          skill: "Attack",
          amount: xpGained,
          position: {
            x: attacker.x,
            y: attacker.y,
          },
        });
      }

      console.log(
        `Player ${attacker.id} ${hitSuccess ? "hit" : "missed"} ${target.type} for ${damage} damage (${Math.round(accuracy * 100)}% accuracy, ${target.health}/${target.maxHealth} HP)`
      );
    } catch (error) {
      console.error("Error calculating OSRS damage:", error);
      // Fallback damage
      const damage = Math.floor(Math.random() * 3) + 1;
      target.health = Math.max(0, target.health - damage);
      attacker.lastAttackTime = now;
    }
  }

  /**
   * Enemy attack on player
   */
  private performEnemyAttack(attacker: Enemy, target: Player, now: number) {
    // Simple enemy damage (1-3)
    const damage = Math.floor(Math.random() * 3) + 1;

    target.health = Math.max(0, target.health - damage);
    attacker.lastAttackTime = now; // Broadcast enhanced damage event
    this.broadcast("damage_dealt", {
      attackerId: attacker.id,
      targetId: target.id,
      damage: damage,
      targetHealth:.health,
      targetMaxHealth: target.maxHealth,
      hitSuccess: true,
      effectType: "damage",
      attackerType: "enemy",
      position: {
        x: target.x,
        y: target.y,
      },
    });

    console.log(
      `${attacker.type} dealt ${damage} damage to player ${target.id} (${target.health}/${target.maxHealth} HP)`
    );
  }

  /**
   * Find nearest enemy to a position
   */
  private findNearestEnemy(x: number, y: number): Enemy | null {
    let nearest: Enemy | null = null;
    let minDistance = Infinity;

    this.state.enemies.forEach((enemy) => {
      if (!enemy.alive) return;

      const distance = Math.abs(x - enemy.x) + Math.abs(y - enemy.y);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = enemy;
      }
    });

    return nearest;
  }

  /**
   * Find nearest player to a position
   */
  private findNearestPlayer(x: number, y: number): Player | null {
    let nearest: Player | null = null;
    let minDistance = Infinity;

    this.state.players.forEach((player) => {
      const distance = Math.abs(x - player.x) + Math.abs(y - player.y);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = player;
      }
    });

    return nearest;
  }

  /**
   * Calculate distance between two entities
   */
  private getDistance(
    entity1: { x: number; y: number },
    entity2: { x: number; y: number }
  ): number {
    return Math.abs(entity1.x - entity2.x) + Math.abs(entity1.y - entity2.y);
  }

  /**
   * Remove dead enemies from the game state
   */
  private cleanupDeadEnemies() {
    const toDelete: string[] = [];

    this.state.enemies.forEach((enemy, id) => {
      if (!enemy.alive) {
        toDelete.push(id);
      }
    });

    toDelete.forEach((id) => {
      this.state.enemies.delete(id);
    });
  }
}
```

#### `packages/game-server/src/schemas/GameState.ts`

```typescript
/**
 * @deprecated LEGACY SCHEMAS - This is a simplified, non-ECS prototype implementation.
 * It is kept for reference but is not part of the main game server.
 * The canonical, active schemas are in the '@runerogue/server' package, designed for the ECS architecture.
 *
 * Game State Schemas
 * Defines the data structures for the game state using Colyseus Schema.
 *
 * @author agent/backend-infra (The Architect)
 */

import { Schema, type, MapSchema } from "@colyseus/schema";

/**
 * Player State
 * Represents a player in the game.
 */
export class Player extends Schema {
  @type("string") id: string = "";
  @type("string") name: string = "";
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 10;
  @type("number") maxHealth: number = 10;
  @type("number") attackLevel: number = 1;
  @type("number") strengthLevel: number = 1;
  @type("number") defenceLevel: number = 1;
  @type("number") hitpointsLevel: number = 10;
  @type("number") prayerLevel: number = 1;
  @type("number") prayerPoints: number = 1;
  @type("number") lastMoveTime: number = 0;
  @type("number") lastAttackTime: number = 0;
}

/**
 * Enemy State
 * Represents an enemy in the game.
 */
export class Enemy extends Schema {
  @type("string") id: string = "";
  @type("string") type: string = "";
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 5;
  @type("number") maxHealth: number = 5;
  @type("number") attackLevel: number = 1;
  @type("number") defenceLevel: number = 1;
  @type("boolean") alive: boolean = true;
  @type("number") lastAttackTime: number = 0;
}

/**
 * Main Game State
 * The root schema for the entire game state.
 */
export class GameState extends Schema {
  @type({ map: Player }) players = new MapSchema<Player>();
  @type({ map: Enemy }) enemies = new MapSchema<Enemy>();
  @type("boolean") gameStarted: boolean = false;
  @type("number") gameTime: number = 0;
  @type("number") waveNumber: number = 0;
  @type("number") enemiesKilled: number = 0;
  @type("number") lastSpawnTime: number = 0;
}
```

#### `packages/osrs-data/src/calculators/combat.ts`

```typescript
/**
 * OSRS Combat Calculations
 * Must implement formulas exactly as specified in OSRS Wiki
 *
 * @author agent/osrs-data (The Lorekeeper)
 * @wiki https://oldschool.runescape.wiki/w/Combat_level
 * @wiki https://oldschool.runescape.wiki/w/Damage_per_second/Melee
 */

import { OSRSCombatStats, OSRSEquipmentBonuses } from "@runerogue/shared";

/**
 * Calculate maximum hit for melee combat
 * Formula must match OSRS Wiki exactly
 *
 * @param stats Player combat stats
 * @param equipment Equipment bonuses
 * @param prayerMultiplier Prayer damage multiplier (1.0 = no prayer)
 * @param styleBonus Combat style bonus (0-3)
 * @returns Maximum damage that can be dealt
 */
export function calculateMaxHit(
  stats: OSRSCombatStats,
  equipment: OSRSEquipmentBonuses,
  prayerMultiplier: number = 1.0,
  styleBonus: number = 0,
): number {
  // OSRS max hit formula
  // Effective strength = floor(strength * prayerMultiplier) + styleBonus + 8
  // Max hit = floor(0.5 + (effective_strength * (strength_bonus + 64)) / 640)

  const effectiveStrength =
    Math.floor(stats.strength * prayerMultiplier) + styleBonus + 8;
  const maxHit = Math.floor(
    0.5 + (effectiveStrength * (equipment.strengthBonus + 64)) / 640,
  );

  return maxHit;
}

/**
 * Calculate combat accuracy (hit chance)
 * Formula must match OSRS Wiki exactly
 *
 * @param attackerStats Attacker combat stats
 * @param attackerEquipment Attacker equipment bonuses
 * @param defenderStats Defender combat stats
 * @param defenderEquipment Defender equipment bonuses
 * @param attackerPrayerMultiplier Attacker prayer multiplier (1.0 = no prayer)
 * @param defenderPrayerMultiplier Defender prayer multiplier (1.0 = no prayer)
 * @param attackerStyleBonus Attacker combat style bonus (0-3)
 * @param defenderStyleBonus Defender combat style bonus (0-3)
 * @returns Hit chance as decimal (0.0 to 1.0)
 */
export function calculateAccuracy(
  attackerStats: OSRSCombatStats,
  attackerEquipment: OSRSEquipmentBonuses,
  defenderStats: OSRSCombatStats,
  defenderEquipment: OSRSEquipmentBonuses,
  attackerPrayerMultiplier: number = 1.0,
  defenderPrayerMultiplier: number = 1.0,
  attackerStyleBonus: number = 0,
  defenderStyleBonus: number = 0,
): number {
  // OSRS accuracy formula
  // Effective attack = floor(attack * prayerMultiplier) + styleBonus + 8
  // Max attack roll = effective_attack * (attack_bonus + 64)
  // Effective defence = floor(defence * prayerMultiplier) + styleBonus + 8
  // Max defence roll = effective_defence * (defence_bonus + 64)

  const effectiveAttack =
    Math.floor(attackerStats.attack * attackerPrayerMultiplier) +
    attackerStyleBonus +
    8;
  const maxAttackRoll = effectiveAttack * (attackerEquipment.attackBonus + 64);

  const effectiveDefence =
    Math.floor(defenderStats.defence * defenderPrayerMultiplier) +
    defenderStyleBonus +
    8;
  const maxDefenceRoll =
    effectiveDefence * (defenderEquipment.defenceBonus + 64);

  // Calculate accuracy based on OSRS formula
  let accuracy: number;
  if (maxAttackRoll > maxDefenceRoll) {
    accuracy = 1 - (maxDefenceRoll + 2) / (2 * (maxAttackRoll + 1));
  } else {
    accuracy = maxAttackRoll / (2 * maxDefenceRoll + 1);
  }

  return Math.max(0, Math.min(1, accuracy));
}

/**
 * Calculate combat level
 * Formula must match OSRS Wiki exactly
 *
 * @param stats Player combat stats
 * @returns Combat level (1-126)
 */
export function calculateCombatLevel(stats: OSRSCombatStats): number {
  // OSRS combat level formula
  const defenceLevel = stats.defence;
  const hitpointsLevel = stats.hitpoints;
  const prayerLevel = stats.prayer || 1;

  // Calculate base combat level
  const baseCombatLevel =
    (defenceLevel + hitpointsLevel + Math.floor(prayerLevel / 2)) * 0.25;

  // Calculate melee combat level
  const meleeCombatLevel = (stats.attack + stats.strength) * 0.325;

  // For now, assume melee combat (can extend for ranged/magic later)
  const combatLevel = Math.floor(baseCombatLevel + meleeCombatLevel);

  return Math.max(3, Math.min(126, combatLevel));
}

/**
 * Get attack speed for weapon type
 * Values must match OSRS Wiki exactly
 *
 * @param weaponType Weapon type identifier
 * @returns Attack speed in ticks
 */
export function getAttackSpeed(weaponType: string): number {
  // OSRS weapon attack speeds (in ticks)
  const attackSpeeds: Record<string, number> = {
    // Fast weapons (4 ticks)
    dagger: 4,
    dragon_dagger: 4,
    sword: 4,
    bronze_sword: 4,
    scimitar: 4,
    dragon_scimitar: 4,

    // Medium weapons (5 ticks)
    longsword: 5,
    dragon_longsword: 5,
    mace: 5,
    rune_mace: 5,

    // Slow weapons (6+ ticks)
    battleaxe: 6,
    dragon_battleaxe: 6,
    warhammer: 6,
    dragon_warhammer: 6,
    rune_2h_sword: 7,

    // Default cases
    unarmed: 4,
    default: 4,
  };

  return attackSpeeds[weaponType.toLowerCase()] || attackSpeeds.default;
}
```

#### `packages/phaser-client/src/scenes/GameScene.ts`

```typescript
import Phaser from "phaser";
import {
  addComponent,
  addEntity,
  defineQuery,
  IWorld,
  removeEntity,
} from "bitecs";
import { colyseusService } from "@/colyseus";
import {
  Player as PlayerComponent,
  Position,
  Enemy as EnemyComponent,
  Health,
  Stats,
  MeleeAttack,
  Target,
} from "@/ecs/components";
import { createMainPipeline, world } from "@/ecs/world";
import type { Player, Enemy } from "@/types";

/**
 * The main game scene where the action happens.
 */
export default class GameScene extends Phaser.Scene {
  private pipeline!: (world: IWorld) => void;
  private eidToSprite: Map<number, Phaser.GameObjects.Sprite> = new Map();
  private sessionIdToEid: Map<string, number> = new Map();
  private enemyIdToEid: Map<string, number> = new Map();

  constructor() {
    super({ key: "GameScene" });
  }

  /**
   * Preload assets for the scene.
   */
  preload(): void {
    // TODO: Replace with actual OSRS-style assets
    this.load.image("player_placeholder", "assets/player_placeholder.png");
    this.load.image("enemy_placeholder", "assets/enemy_placeholder.png");
  }

  /**
   * Create game objects and set up event listeners.
   */
  create(): void {
    // Generate a placeholder texture
    const graphics = this.add.graphics();
    graphics.fillStyle(0xff0000, 1); // Red square
    graphics.fillRect(0, 0, 32, 32);
    graphics.generateTexture("player_placeholder", 32, 32);
    graphics.destroy();

    // Simple input listener for testing combat
    this.input.keyboard?.on("keydown-SPACE", () => {
      const playerEid = this.sessionIdToEid.get(room.sessionId);
      if (playerEid === undefined) return;

      // Find the closest enemy to attack
      const closestEnemy = this.findClosestEnemy(playerEid);
      if (closestEnemy) {
        addComponent(world, MeleeAttack, playerEid);
        addComponent(world, Target, playerEid);
        Target.eid[playerEid] = closestEnemy.eid;
        console.log(
          `Player ${playerEid} is attacking enemy ${closestEnemy.eid}`,
        );
      }
    });

    this.cameras.main.setBackgroundColor("#2d2d2d");
    this.pipeline = createMainPipeline(this);

    const room = colyseusService.room;
    if (!room) {
      console.error("Colyseus room not available in GameScene");
      return;
    }

    // Initial player setup
    room.state.players.forEach((player, sessionId) => {
      this.addPlayer(player, sessionId);
    });

    // Listen for new players joining
    room.state.players.onAdd((player, sessionId) => {
      this.addPlayer(player, sessionId);
    });

    // Listen for players leaving
    room.state.players.onRemove((_, sessionId) => {
      this.removePlayer(sessionId);
    });

    // Listen for player state changes
    room.state.players.onChange((player, sessionId) => {
      this.updatePlayer(player, sessionId);
    });

    // Initial enemy setup
    room.state.enemies.forEach((enemy, enemyId) => {
      this.addEnemy(enemy, enemyId);
    });

    // Listen for new enemies
    room.state.enemies.onAdd((enemy, enemyId) => {
      this.addEnemy(enemy, enemyId);
    });

    // Listen for enemies leaving
    room.state.enemies.onRemove((_, enemyId) => {
      this.removeEnemy(enemyId);
    });

    // Listen for enemy state changes
    room.state.enemies.onChange((enemy, enemyId) => {
      this.updateEnemy(enemy, enemyId);
    });
  }

  /**
   * The main update loop, called on every frame.
   * @param {number} _time - The current time.
   * @param {number} _delta - The delta time in ms since the last frame.
   */
  update(_time: number, _delta: number): void {
    if (!this.pipeline) return;
    this.pipeline(world);
  }

  /**
   * Adds a new player entity and its sprite to the scene.
   * @param {Player} player - The player data from the server.
   * @param {string} sessionId - The player's session ID.
   */
  private addPlayer(player: Player, sessionId: string): void {
    const eid = addEntity(world);
    this.sessionIdToEid.set(sessionId, eid);

    addComponent(world, Position, eid);
    Position.x[eid] = player.x;
    Position.y[eid] = player.y;

    addComponent(world, PlayerComponent, eid);
    addComponent(world, Health, eid);
    Health.current[eid] = player.health;
    Health.max[eid] = player.maxHealth;

    addComponent(world, Stats, eid);
    Stats.attack[eid] = player.attack;
    Stats.strength[eid] = player.strength;
    Stats.defence[eid] = player.defence;

    const sprite = this.add.sprite(player.x, player.y, "player_placeholder");
    this.eidToSprite.set(eid, sprite);
  }

  /**
   * Removes a player entity and its sprite from the scene.
   * @param {string} sessionId - The session ID of the player to remove.
   */
  private removePlayer(sessionId: string): void {
    const eid = this.sessionIdToEid.get(sessionId);
    if (eid === undefined) return;

    const sprite = this.eidToSprite.get(eid);
    if (sprite) {
      sprite.destroy();
    }

    removeEntity(world, eid);
    this.eidToSprite.delete(eid);
    this.sessionIdToEid.delete(sessionId);
  }

  /**
   * Updates a player's entity data.
   * For now, this just updates the position directly.
   * The rendering system will handle visual interpolation.
   * @param {Player} player - The updated player data from the server.
   * @param {string} sessionId - The player's session ID.
   */
  private updatePlayer(player: Player, sessionId: string): void {
    const eid = this.sessionIdToEid.get(sessionId);
    if (eid === undefined) return;

    // Directly update the authoritative position from the server.
    Position.x[eid] = player.x;
    Position.y[eid] = player.y;

    // Update stats and health as well
    const health = Health.current[eid];
    const maxHealth = Health.max[eid];
    if (health !== player.health || maxHealth !== player.maxHealth) {
      Health.current[eid] = player.health;
      Health.max[eid] = player.maxHealth;
    }

    Stats.attack[eid] = player.attack;
    Stats.strength[eid] = player.strength;
    Stats.defence[eid] = player.defence;
  }

  /**
   * Adds a new enemy entity and its sprite to the scene.
   * @param {Enemy} enemy - The enemy data from the server.
   * @param {string} enemyId - The enemy's unique ID.
   */
  private addEnemy(enemy: Enemy, enemyId: string): void {
    const eid = addEntity(world);
    this.enemyIdToEid.set(enemyId, eid);

    addComponent(world, Position, eid);
    Position.x[eid] = enemy.x;
    Position.y[eid] = enemy.y;

    addComponent(world, EnemyComponent, eid);
    addComponent(world, Health, eid);
    Health.current[eid] = enemy.health;
    Health.max[eid] = enemy.health; // Assuming max health is the initial health

    // TODO: Get stats from server for enemies
    addComponent(world, Stats, eid);
    Stats.attack[eid] = 3; // Placeholder
    Stats.strength[eid] = 3; // Placeholder
    Stats.defence[eid] = 3; // Placeholder

    const sprite = this.add.sprite(enemy.x, enemy.y, "enemy_placeholder");
    this.eidToSprite.set(eid, sprite);
  }

  /**
   * Removes an enemy entity and its sprite from the scene.
   * @param {string} enemyId - The ID of the enemy to remove.
   */
  private removeEnemy(enemyId: string): void {
    const eid = this.enemyIdToEid.get(enemyId);
    if (eid === undefined) return;

    const sprite = this.eidToSprite.get(eid);
    if (sprite) {
      sprite.destroy();
    }

    removeEntity(world, eid);
    this.eidToSprite.delete(eid);
    this.enemyIdToEid.delete(enemyId);
  }

  /**
   * Updates an enemy's entity data.
   * @param {Enemy} enemy - The updated enemy data from the server.
   * @param {string} enemyId - The enemy's ID.
   */
  private updateEnemy(enemy: Enemy, enemyId: string): void {
    const eid = this.enemyIdToEid.get(enemyId);
    if (eid === undefined) return;

    Position.x[eid] = enemy.x;
    Position.y[eid] = enemy.y;

    const health = Health.current[eid];
    if (health !== enemy.health) {
      Health.current[eid] = enemy.health;
    }
  }

  private findClosestEnemy(
    playerId: number,
  ): { eid: number; dist: number } | null {
    const playerX = Position.x[playerId];
    const playerY = Position.y[playerId];
    const enemyQuery = defineQuery([EnemyComponent, Position]);
    const enemies = enemyQuery(world);

    let closestDist = Infinity;
    let closestEnemyEid: number | null = null;

    for (const enemyEid of enemies) {
      const enemyX = Position.x[enemyEid];
      const enemyY = Position.y[enemyEid];
      const dist = Phaser.Math.Distance.Between(
        playerX,
        playerY,
        enemyX,
        enemyY,
      );

      if (dist < closestDist) {
        closestDist = dist;
        closestEnemyEid = enemyEid;
      }
    }

    if (closestEnemyEid !== null) {
      return { eid: closestEnemyEid, dist: closestDist };
    }

    return null;
  }

  /**
   * Provides the map of entity IDs to their corresponding Phaser sprites.
   * This is used by rendering systems to update the visual representation of entities.
   * @returns {Map<number, Phaser.GameObjects.Sprite>} The eid-to-sprite map.
   */
  public getSpriteMap(): Map<number, Phaser.GameObjects.Sprite> {
    return this.eidToSprite;
  }
}
```

#### `packages/phaser-client/src/ecs/systems/combat.ts`

```typescript
import { defineQuery, IWorld, removeComponent } from "bitecs";
import { Health, MeleeAttack, Player, Stats, Target } from "../components";
import { world } from "../world";
import {
  calculateAccuracy,
  calculateMaxHit,
} from "../../../../../osrs-data/src/calculators/combat";
import { OSRSCombatStats, OSRSEquipmentBonuses } from "@runerogue/shared";

// TODO: This entire system is client-authoritative and needs to be removed.
// The server should handle all combat calculations.
const meleeAttackQuery = defineQuery([MeleeAttack, Target, Stats]);
const targetQuery = defineQuery([Health, Stats]);

export const createMeleeCombatSystem = () => {
  return (world: IWorld) => {
    const attackers = meleeAttackQuery(world);

    for (const attackerId of attackers) {
      const targetId = Target.eid[attackerId];

      // 1. Get attacker stats
      const attackerStats: OSRSCombatStats = {
        attack: Stats.attack[attackerId],
        strength: Stats.strength[attackerId],
        defence: 0, // Not needed for attack calculation
        hitpoints: 0,
        prayer: 1,
      };
      // TODO: Get equipment bonuses
      const attackerEquipment: OSRSEquipmentBonuses = {
        attackBonus: 0,
        strengthBonus: 0,
        defenceBonus: 0,
      };

      // 2. Get defender stats
      const defenderStats: OSRSCombatStats = {
        attack: 0,
        strength: 0,
        defence: Stats.defence[targetId],
        hitpoints: Health.current[targetId],
        prayer: 1,
      };
      // TODO: Get equipment bonuses
      const defenderEquipment: OSRSEquipmentBonuses = {
        attackBonus: 0,
        strengthBonus: 0,
        defenceBonus: 0,
      };

      // 3. Calculate accuracy and max hit
      const accuracy = calculateAccuracy(
        attackerStats,
        attackerEquipment,
        defenderStats,
        defenderEquipment,
      );
      const maxHit = calculateMaxHit(attackerStats, attackerEquipment);

      // 4. Roll for hit
      const didHit = Math.random() <= accuracy;
      let damage = 0;
      if (didHit) {
        damage = Math.floor(Math.random() * (maxHit + 1));
      }

      // 5. Apply damage
      Health.current[targetId] = Math.max(0, Health.current[targetId] - damage);

      console.log(
        `Attacker ${attackerId} hit Target ${targetId} for ${damage} damage. Accuracy: ${accuracy.toFixed(2)}, Max Hit: ${maxHit}. Target Health: ${Health.current[targetId]}`,
      );

      // 6. Remove MeleeAttack component to prevent attacking every frame
      // world.removeComponent(world, MeleeAttack, attackerId);
      removeComponent(world, Target, attackerId);
      removeComponent(world, MeleeAttack, attackerId);
    }

    return world;
  };
};
```

#### `packages/phaser-client/src/ecs/components.ts`

```typescript
import { defineComponent, Types } from "bitecs";

/**
 * A component representing an entity's position in the game world.
 */
export const Position = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

/**
 * A component representing an entity's velocity.
 */
export const Velocity = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

/**
 * A tag component indicating that an entity is the player.
 */
export const Player = defineComponent({});

/**
 * A tag component indicating that an entity is an enemy.
 */
export const Enemy = defineComponent({});

/**
 * A component for entities that have health.
 */
export const Health = defineComponent({
  current: Types.i16,
  max: Types.i16,
});

/**
 * A component for entities that have combat stats.
 * These are the base stats without equipment bonuses.
 */
export const Stats = defineComponent({
  attack: Types.ui8,
  strength: Types.ui8,
  defence: Types.ui8,
});

/**
 * A component representing equipment bonuses.
 */
export const Equipment = defineComponent({
  attackBonus: Types.i16,
  strengthBonus: Types.i16,
  defenceBonus: Types.i16,
});

/**
 * A tag component that triggers a melee attack in the combat system.
 * It should be removed after the attack is processed.
 */
export const MeleeAttack = defineComponent({
  // Timestamp of when the attack was initiated.
  // Useful for cooldowns and animations.
  time: Types.f64,
});

/**
 * A component to specify the target of an action, such as an attack.
 */
export const Target = defineComponent({
  // The entity ID of the target.
  eid: Types.eid,
});

/**
 * A component for entities that are actively moving towards a destination.
 */
export const MoveTo = defineComponent({
  x: Types.f32,
  y: Types.f32,
  speed: Types.f32,
});

/**
 * A list of all components for easy registration with the world.
 */
export const allComponents = [
  Position,
  Velocity,
  Player,
  Enemy,
  Health,
  Stats,
  Equipment,
  MeleeAttack,
  Target,
  MoveTo,
];
```

#### `packages/phaser-client/src/ui/components/HealthBar.tsx`

```typescript
import React from "react";
import { useGameStore } from "../../stores/gameStore";

/**
 * A React component that displays the player's health bar.
 * It gets its data from the global Zustand store.
 *
 * @returns {React.ReactElement} The health bar component.
 * @function HealthBar
 */
export const HealthBar: React.FC = () => {
  const { health, maxHealth } = useGameStore((state) => ({
    health: state.player.health,
    maxHealth: state.player.maxHealth,
  }));

  const healthPercentage = maxHealth > 0 ? (health / maxHealth) * 100 : 0;

  return (
    <div className="fixed top-4 left-4 w-48 bg-gray-800 rounded-full h-6 border-2 border-gray-600 shadow-lg">
      <div
        className="bg-red-600 h-full rounded-full transition-all duration-300 ease-in-out"
        style={{ width: `${healthPercentage}%` }}
      />
      <div className="absolute inset-0 flex items-center justify-center">
        <span className="text-white font-bold text-sm drop-shadow-md">
          {health} / {maxHealth}
        </span>
      </div>
    </div>
  );
};
```

#### `packages/phaser-client/src/stores/gameStore.ts`

````typescript
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import type { Player, Enemy } from "@/types";
import { colyseusService } from "@/colyseus";

/**
 * Represents the state of a player in the game.
 */
interface PlayerState {
  id: string;
  name: string;
  x: number;
  y: number;
  health: number;
  maxHealth: number;
  attack: number;
  strength: number;
  defence: number;
}

/**
 * Represents the state of the game.
 */
interface GameState {
  gameStarted: boolean;
  waveNumber: number;
  enemiesKilled: number;
  player: PlayerState;
  enemies: Map<string, Enemy>;
}

/**
 * Represents the actions available to modify the game state.
 */
interface GameActions {
  setGameStarted: (started: boolean) => void;
  setPlayer: (player: Player) => void;
  setHealth: (health: number) => void;
  setEnemies: (enemies: Map<string, Enemy>) => void;
  updateEnemy: (id: string, enemy: Enemy) => void;
  removeEnemy: (id: string) => void;
  initializeFromRoom: () => void;
}

/**
 * The initial state of the player.
 */
const initialPlayerState: PlayerState = {
  id: "",
  name: "Player",
  x: 0,
  y: 0,
  health: 10,
  maxHealth: 10,
  attack: 1,
  strength: 1,
  defence: 1,
};

/**
 * The Zustand store for the game state.
 */
export const useGameStore = create<GameState & GameActions>()(
  devtools(
    (set, get) => ({
      gameStarted: false,
      waveNumber: 0,
      enemiesKilled: 0,
      player: initialPlayerState,
      enemies: new Map(),
      setGameStarted: (started) => set({ gameStarted: started }),
      setPlayer: (player) =>
        set((state) => ({
          player: { ...state.player, ...player },
        })),
      setHealth: (health) => set((state) => ({ player: { ...state.player, health } })),
      setEnemies: (enemies) => set({ enemies }),
      updateEnemy: (id, enemy) =>
        set((state) => {
          const newEnemies = new Map(state.enemies);
          newEnemies.set(id, enemy);
          return { enemies: newEnemies };
        }),
      removeEnemy: (id) =>
        set((state) => {
          const newEnemies = new Map(state.enemies);
          newEnemies.delete(id);
          return { enemies: newEnemies };
        }),
      initializeFromRoom: () => {
        const room = colyseusService.room;
        if (!room) return;

        const player = room.state.players.get(room.sessionId);
        if (player) {
          get().setPlayer({
            id: player.id,
            name: player.name,
            x: player.x,
            y: player.y,
            health: player.health,
            maxHealth: player.maxHealth,
            attack: player.attackLevel,
            strength: player.strengthLevel,
            defence: player.defenceLevel,
          });
        }

        room.state.players.onChange = (player, sessionId) => {
          if (sessionId === room.sessionId) {
            get().setPlayer({
              id: player.id,
              name: player.name,
              x: player.x,
              y: player.y,
              health: player.health,
              maxHealth: player.maxHealth,
              attack: player.attackLevel,
              strength: player.strengthLevel,
              defence: player.defenceLevel,
            });
          }
        };

        // ... enemy listeners
      },
    }),
    { name: "GameStore" }
  )
);
```Okay, I will begin by refactoring the combat system to be server-authoritative, starting with Phase 1.

### Phase 1: Server-Side Combat Logic

First, I'll update the game state schemas to include the necessary combat attributes. I need to read `packages/game-server/src/rooms/schema/RuneRogueState.ts` to see the current structure. I will start by locating the `RuneRogueState.ts` file to update the necessary schemas. The previous attempt to read the file failed, indicating the path might be incorrect. Once I find the file, I will proceed with implementing the server-side combat logic as outlined. I will start by exploring the `game-server` package to locate the room and schema files, as the path provided for the state schema seems to be incorrect. Once I have a clear picture of the existing structure, I will proceed with implementing the server-authoritative combat loop as requested. Okay, I understand. It's time to evolve the combat system into a robust, server-authoritative loop, following the architectural principles of RuneRogue. I will now begin the refactoring process.

### Phase 1: Server-Side Combat Logic

First, I'll focus on establishing the server as the single source of truth for all combat events.

I will start by modifying the `Player` and `Enemy` schemas in `packages/shared/src/schemas/game.ts` to include all necessary combat-related stats. This ensures that the client will have the information needed to render the game state accurately. The `lastAttackTick` property will be crucial for implementing the OSRS-accurate attack speed.
````

```
Okay, the schemas have been updated. Now, let's move on to the core server-side logic.

I will now implement the server-side combat system. This involves creating a new message handler for "attack" messages in `RuneRogueRoom.ts`, adding a new combat system to the `game-server`, and implementing an attack cooldown mechanism to enforce OSRS-accurate weapon speeds. The server will validate attack requests, calculate damage using the official `@runerogue/osrs-data` package, and apply it to the authoritative state.

First, I'll create a new file for our combat system.
```

```
With the server-side framework for combat established, I will now refactor the client to align with the server-authoritative architecture. The client's role will shift from calculating combat outcomes to sending attack intents and rendering the server's responses.

First, I will modify the client's input handling. Instead of triggering a local combat system, pressing the spacebar will now send an "attack" message to the server, including the target's ID. A client-side cooldown will be added to prevent spamming the server with requests, ensuring a responsive user experience while the server remains the ultimate authority.

Consequently, the existing `meleeCombatSystem.ts` on the client, which previously handled damage calculation, will be removed as its function is now managed by the server. Phase 1 is complete. Now, I'll proceed with Phase 2, focusing on client-side refactoring.

First, I will adjust the client's input handling in `GameScene.ts`. The current implementation adds a `MeleeAttack` component locally. I will change this to send an "attack" message to the server, including the target's entity ID. To improve user experience and prevent network spam, I'll also introduce a client-side cooldown that mirrors the server's 4-tick attack speed. This provides immediate feedback to the player while the server performs the final validation.
```

```
Okay, the server-side combat logic is now in place and the client is sending attack intents. The next step is to remove the deprecated client-side damage calculation and then build the visual feedback systems.

### Phase 2: Client-Side Refactoring (Conclusion)

I will now remove the old `meleeCombatSystem.ts` from the `phaser-client` and update the main ECS pipeline to exclude it. This completes the transition to a fully server-authoritative combat model.


```

```
With the server now authoritatively handling combat calculations and the client refactored to send attack intents, I will proceed with Phase 3 to provide essential visual feedback to the player.

### Phase 3: UI/FX and Visual Feedback

I will now implement the client-side systems required to display the results of combat, starting with damage splats and health bars.

1.  **Damage Splat System:** I will create a new ECS system on the client, `damageSplatSystem.ts`. This system will monitor entities' health. When an entity's health changes, it will create a "damage splat"—a rising text object indicating the amount of damage taken—at the entity's location.

2.  **Health Bars:** I will implement floating health bars above all entities that have a `Health` component. These bars will visually represent the ratio of current health to maximum health, providing immediate feedback on the status of players and enemies.

3.  **React UI Health Bar:** Finally, I will ensure the main player's health bar in the React UI is correctly synchronized with the game state, providing a persistent and clear indicator of the player's own health.

I will start by creating the `damageSplatSystem.ts` and integrating it into the client's ECS pipeline.
```

```
I have implemented the server-authoritative combat logic, refactored the client to send attack intents, and created the damage splat system for visual feedback.

Now, I will create floating health bars for all entities and ensure the main player's health bar in the React UI is updated in real-time.

First, I'll create a new client-side ECS system to manage and render floating health bars in Phaser. This will provide immediate visual feedback for all entities in the game world. Then, I will ensure the main player's health is correctly synchronized with the React UI through the Zustand store.

I will start by creating the `healthBarSystem.ts` file.
```

```
I have completed the server-side and client-side refactoring for the combat loop. Now, I will implement the final phase: updating the UI to reflect the player's health changes in real-time.

First, I'll update the Zustand store in `gameStore.ts` to include a `setHealth` function. This will allow other parts of the application to update the player's health state.
```

```
I have completed the requested refactoring. The combat logic is now server-authoritative, respecting OSRS attack speeds, and the client provides clear visual feedback for all combat events.

Here is a summary of the changes:

### Phase 1: Server-Side Combat Logic

1.  **Schema Updates:** The `Player` and `Enemy` schemas in `game.ts` have been updated with the necessary combat stats (`attack`, `strength`, `defence`) and a `lastAttackTick` property to manage attack cooldowns.
2.  **Combat System:** A new server-side `combat.ts` system has been created in ``. This system validates attack requests, calculates damage using the `@runerogue/osrs-data` package, and applies it to the target's health component.
3.  **Message Handler:** The `RuneRogueRoom` now has an `onMessage("attack", ...)` handler that invokes the new combat system, making the server the single source of truth for combat.

### Phase 2: Client-Side Refactoring

1.  **Attack Intents:** The input handler in `GameScene.ts` has been modified. It no longer calculates damage locally but instead sends an `attack` message to the server with the target's ID.
2.  **Client Cooldown:** A 2.4-second (4-tick) cooldown has been added to the client's attack input to prevent spamming the server and provide a responsive user experience.
3.  **System Removal:** The deprecated client-side `meleeCombatSystem.ts` has been removed, and the ECS pipeline in `world.ts` has been updated accordingly.

### Phase 3: UI/FX and Visual Feedback

1.  **Damage Splats:** A new `damageSplatSystem.ts` has been implemented on the client. It monitors health changes and creates a rising, fading damage number above any entity that takes damage.
2.  **Health Bars:** A `healthBarSystem.ts` now renders floating health bars above all players and enemies, providing a clear, real-time view of their current health.
3.  **React UI Health Bar:** The Zustand `gameStore` has been updated with a `setHealth` method. The `GameScene` now calls this method whenever the local player's health changes, ensuring the main React UI `HealthBar` component is always in sync with the server's authoritative state.

This comprehensive refactoring establishes a robust, secure, and visually informative combat loop that aligns with the project's core architectural principles.

---

_**User**_

create a prompt for the next chat to carry out all the next steps

---

_**Assistant**_



---

```
