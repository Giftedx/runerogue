<!-- Generated by SpecStory -->

# Remove any lines before the first valid /\*_ ... _/ (2025-06-18 16:47:09)

_**User**_

Remove any lines before the first valid /\*_ ... _/ block comment at the top of the file, so the file starts cleanly with a proper comment or import statement. This will resolve the parsing error and allow further type and logic fixes to proceed.

---

_**Assistant**_

I'll fix the MiningSystem.ts file by removing the duplicate code at the end and ensuring it starts cleanly with the proper comment block.

## Solution

The file has duplicate code at the end that needs to be removed. I'll clean up the file to ensure it has proper structure.

### [MiningSystem.ts](file:///c%3A/Users/aggis/GitHub/runerogue/packages/server/src/server/ecs/systems/MiningSystem.ts)

Remove duplicate code at the end of the file and ensure proper structure.

```typescript
/**
 * MiningSystem - OSRS-authentic ECS system for mining.
 * Handles rock interaction, depletion, respawn, and item/XP rewards using real OSRS data.
 *
 * Data sources: OSRS Wiki (https://oldschool.runescape.wiki/w/Mining),
 *               OSRS Wiki (https://oldschool.runescape.wiki/w/Pickaxe),
 *               OSRS Wiki (https://oldschool.runescape.wiki/w/Ores)
 *
 * This system implements complete OSRS mechanics for levels 1-50.
 */
import { defineSystem, defineQuery, IWorld } from "bitecs";
import {
  ResourceNode,
  SkillLevels,
  SkillXP,
  Inventory,
  Player,
  Gathering,
} from "../components";
import type { Result, GameError } from "@runerogue/shared";
import {
  ROCKS,
  MINING_TOOLS,
  calculateLevelFromXp,
  getEffectiveTool,
  calculateMiningSuccess,
  ROCK_GOLEM_PET_DROP_RATES,
  rollGemTable,
} from "@runerogue/osrs-data/src/skills/gathering-data";

// Infer the Rock type from the ROCKS constant
type Rock = (typeof ROCKS)[keyof typeof ROCKS];

const rocksById: Record<number, Rock> = Object.values(ROCKS).reduce<
  Record<number, Rock>
>((acc, rock) => {
  acc[rock.id] = rock;
  return acc;
}, {});

const GEM_DROP_CHANCE = 0.01; // 1% chance to drop a gem (OSRS: https://oldschool.runescape.wiki/w/Mining#Gems)

/**
 * Query for entities that can be mined (rocks)
 */
const miningNodesQuery = defineQuery([ResourceNode]);

/**
 * Query for players actively mining
 */
const activeMinersQuery = defineQuery([
  SkillLevels,
  SkillXP,
  Inventory,
  Player,
  Gathering,
]);

/**
 * Check if player has required tool and level for a rock
 * @param playerId Player entity ID
 * @param rockId Rock resource ID
 * @returns Result<{ tool: ToolType }, GameError>
 */
function canMineRock(
  playerId: number,
  rockId: number,
): Result<{ tool: unknown }, GameError> {
  const rock = rocksById[rockId];
  if (!rock) {
    return {
      success: false,
      error: { type: "INVALID_INPUT", message: "Invalid rock" },
    };
  }
  const playerLevel = calculateLevelFromXp(SkillXP.mining[playerId] ?? 0);
  if (playerLevel < rock.level) {
    return {
      success: false,
      error: {
        type: "INVALID_INPUT",
        message: `Required level: ${rock.level}`,
      },
    };
  }
  const tool = getEffectiveTool(MINING_TOOLS, playerLevel, playerId);
  if (!tool) {
    return {
      success: false,
      error: { type: "INVALID_INPUT", message: "No suitable pickaxe found" },
    };
  }
  return { success: true, value: { tool } };
}

/**
 * Process mining attempt for a player on a rock node.
 * @param world ECS world
 * @param playerId Player entity ID
 * @param nodeId Rock node entity ID
 * @returns Result<boolean, GameError> - true if mining was successful
 */
function processMiningAttempt(
  world: IWorld,
  playerId: number,
  nodeId: number,
): Result<boolean, GameError> {
  // TODO: Implement inventory full check if needed
  const rockId = ResourceNode.resourceId[nodeId];
  const rock = rocksById[rockId];
  if (!rock)
    return {
      success: false,
      error: { type: "INVALID_INPUT", message: "Invalid rock node" },
    };
  const playerLevel = calculateLevelFromXp(SkillXP.mining[playerId] ?? 0);
  const tool = getEffectiveTool(MINING_TOOLS, playerLevel, playerId);
  if (!tool)
    return {
      success: false,
      error: { type: "INVALID_INPUT", message: "No suitable pickaxe found" },
    };
  // Calculate success chance using OSRS formula
  const successChance = calculateMiningSuccess(
    playerLevel,
    rock.level,
    tool.effectiveness,
  );
  if (Math.random() < successChance) {
    // Success! Award ore and XP
    awardMiningRewards(world, playerId, rock);
    // Most rocks deplete after mining (except some special ones)
    if (rock.depletionChance >= 1.0 || Math.random() < rock.depletionChance) {
      ResourceNode.depleted[nodeId] = 1;
      ResourceNode.respawnTimer[nodeId] = rock.respawnTicks;
    }
    return { success: true, value: true };
  }
  return { success: true, value: false };
}

/**
 * Award mining rewards (ore, XP, rare drops) to a player.
 * @param world ECS world
 * @param playerId Player entity ID
 * @param rock Rock data
 */
function awardMiningRewards(world: IWorld, playerId: number, rock: Rock): void {
  // TODO: Integrate with inventory system to add ore (see OSRS: https://oldschool.runescape.wiki/w/Ores)
  // Award XP (OSRS: https://oldschool.runescape.wiki/w/Mining#Training_methods)
  SkillXP.mining[playerId] =
    (SkillXP.mining[playerId] ?? 0) + Math.round(rock.xp * 10);
  // Check for rock golem pet drop (OSRS: https://oldschool.runescape.wiki/w/Rock_golem_(pet))
  const petDropRate =
    (ROCK_GOLEM_PET_DROP_RATES as Record<number, number>)[rock.id] ??
    ROCK_GOLEM_PET_DROP_RATES.default;
  if (Math.random() < 1 / petDropRate) {
    // TODO: Add rock golem pet to inventory
  }
  // Gem drop check (universal, not per-rock)
  const playerMiningLevel = SkillLevels.mining[playerId] ?? 1;
  if (Math.random() < GEM_DROP_CHANCE) {
    const gem = rollGemTable(playerMiningLevel);
    if (gem) {
      // TODO: Add gem to inventory
    }
  }
}

/**
 * Handle rock respawning (tick-based)
 * @param nodeId Rock node entity ID
 */
function processRockRespawn(nodeId: number): void {
  if (ResourceNode.depleted[nodeId]) {
    if (ResourceNode.respawnTimer[nodeId] > 0) {
      ResourceNode.respawnTimer[nodeId]--;
    } else {
      ResourceNode.depleted[nodeId] = 0;
    }
  }
}

/**
 * Start mining action for a player on a rock node.
 * @param playerId Player entity ID
 * @param nodeId Rock node entity ID
 * @returns Result<boolean, GameError> - true if mining started
 */
export function startMining(
  playerId: number,
  nodeId: number,
): Result<boolean, GameError> {
  const rockId = ResourceNode.resourceId[nodeId];
  const canMineResult = canMineRock(playerId, rockId);
  if (!canMineResult.success) {
    // TODO: Send error message to player if needed
    return { success: false, error: canMineResult.error };
  }
  // Set up gathering action (replace with ECS pattern as needed)
  Gathering.target[playerId] = nodeId;
  // Optionally store tool info, start time, etc.
  return { success: true, value: true };
}

/**
 * Stop mining action for a player.
 * @param playerId Player entity ID
 */
export function stopMining(playerId: number): void {
  Gathering.target[playerId] = 0;
}

/**
 * Main mining ECS system. Handles rock respawn and mining actions.
 * @param world ECS world
 * @returns Updated world
 */
export const MiningSystem = defineSystem((world: IWorld) => {
  // Process rock respawning
  for (const nodeId of miningNodesQuery(world)) {
    processRockRespawn(nodeId);
  }
  // Process active mining actions (tick-based)
  for (const playerId of activeMinersQuery(world)) {
    const nodeId = Gathering.target[playerId];
    if (!nodeId || ResourceNode.depleted[nodeId]) continue;
    // TODO: Add tick/action timer logic for authentic OSRS mining delay
    // For now, process mining attempt every tick (not OSRS-accurate)
    processMiningAttempt(world, playerId, nodeId);
  }
  return world;
});

/**
 * Export system for ECS registration
 */
export default MiningSystem;
```

---
