<!-- Generated by SpecStory -->

# /fix  (2025-06-21 04:33:15)

_**User**_

/fix 

---

_**Assistant**_

Looking at the `NEXT_STEPS.md` file and the current `GameRoom.ts` implementation, I can see that the core combat loop is partially implemented but needs to be completed. Let me propose a comprehensive solution to implement the full combat loop as outlined in the next steps.

## Solution Overview

I'll implement the following changes step-by-step:

1. **Update shared schemas** to include EnemySchema
2. **Enhance the CombatSystem** to use OSRS formulas and handle entity death
3. **Update EnemySpawnSystem** to create synced enemies
4. **Modify GameRoom** to handle entity cleanup
5. **Update the client** to render enemies and combat feedback

## Implementation

### packages/shared/src/schemas/GameState.ts

Add the EnemySchema definition and update GameRoomState:

````typescript
import { Schema, type, MapSchema } from "@colyseus/schema";

/**
 * Base entity schema with common properties
 */
export class EntitySchema extends Schema {
  @type("string") id: string = "";
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 0;
  @type("number") maxHealth: number = 0;
  @type("number") ecsId?: number;
}

/**
 * Player entity schema
 */
export class PlayerSchema extends EntitySchema {
  @type("string") name: string = "";
  @type("number") combatLevel: number = 3;
}

/**
 * Enemy entity schema
 */
export class EnemySchema extends EntitySchema {
  @type("string") enemyType: string = "goblin";
  @type("number") combatLevel: number = 2;
}

/**
 * Main game room state
 */
export class GameRoomState extends Schema {
  @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
  @type({ map: EnemySchema }) enemies = new MapSchema<EnemySchema>();
  @type("number") waveNumber: number = 1;
  @type("number") enemiesRemaining: number = 0;
}
````

### packages/game-server/src/ecs/systems/CombatSystem.ts

Update the combat system to use OSRS formulas and handle proximity-based combat:

````typescript
import { defineQuery, defineSystem, IWorld, removeEntity } from "bitecs";
import { Position, Health, Target, Combat } from "../components";
import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";
import type { GameRoom } from "../../rooms/GameRoom";

/**
 * Extended world interface with game-specific properties
 */
interface CombatWorld extends IWorld {
  time: {
    elapsed: number;
    delta: number;
  };
  room: GameRoom;
}

/**
 * Calculate distance between two entities
 */
function getDistance(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Combat system that handles attack proximity, damage calculation, and entity death
 */
export const createCombatSystem = () => {
  const combatQuery = defineQuery([Position, Health, Target, Combat]);
  const damageableQuery = defineQuery([Position, Health]);

  return defineSystem((world: CombatWorld) => {
    const entities = combatQuery(world);
    const currentTime = world.time.elapsed;

    for (let i = 0; i < entities.length; i++) {
      const eid = entities[i];
      const targetEid = Target.eid[eid];

      // Skip if no target or target doesn't exist
      if (!targetEid || !damageableQuery(world).includes(targetEid)) {
        Target.eid[eid] = 0;
        continue;
      }

      // Check if target is within attack range (1 tile = 32 pixels)
      const attackerX = Position.x[eid];
      const attackerY = Position.y[eid];
      const targetX = Position.x[targetEid];
      const targetY = Position.y[targetEid];
      const distance = getDistance(attackerX, attackerY, targetX, targetY);
      
      const ATTACK_RANGE = 40; // Slightly more than 1 tile for melee
      if (distance > ATTACK_RANGE) {
        continue;
      }

      // Check if attack timer is ready
      const lastAttackTime = Combat.lastAttackTime[eid] || 0;
      const attackCooldown = Combat.attackSpeed[eid] || 2400; // Default 4-tick weapon
      
      if (currentTime - lastAttackTime < attackCooldown) {
        continue;
      }

      // Update attack timer
      Combat.lastAttackTime[eid] = currentTime;

      // Calculate damage using OSRS formulas
      const attackerStats = {
        attackLevel: Combat.attack[eid] || 1,
        strengthLevel: Combat.strength[eid] || 1,
        defenceLevel: Combat.defence[eid] || 1,
        attackBonus: 0, // TODO: Equipment bonuses
        strengthBonus: 0,
        defenceBonus: 0,
        attackStyle: "aggressive" as const,
        combatType: "melee" as const,
        prayers: [] as string[],
      };

      const defenderStats = {
        attackLevel: Combat.attack[targetEid] || 1,
        strengthLevel: Combat.strength[targetEid] || 1,
        defenceLevel: Combat.defence[targetEid] || 1,
        attackBonus: 0,
        strengthBonus: 0,
        defenceBonus: 0,
        attackStyle: "defensive" as const,
        combatType: "melee" as const,
        prayers: [] as string[],
      };

      // Calculate hit chance and damage
      const accuracy = calculateAccuracy(attackerStats, defenderStats);
      const maxHit = calculateMaxHit(attackerStats);
      
      // Roll for hit
      let damage = 0;
      if (Math.random() < accuracy) {
        // Roll damage between 0 and max hit
        damage = Math.floor(Math.random() * (maxHit + 1));
      }

      // Apply damage
      if (damage > 0) {
        Health.current[targetEid] = Math.max(0, Health.current[targetEid] - damage);
        
        // Emit damage event for client feedback
        world.room.broadcast("damage", {
          targetId: targetEid,
          damage: damage,
          attackerId: eid,
        });
      }

      // Handle death
      if (Health.current[targetEid] <= 0) {
        // Find and remove from state
        const deadEntity = world.room.findEntityById(targetEid);
        if (deadEntity) {
          if (deadEntity.type === "player") {
            world.room.handlePlayerDeath(deadEntity.sessionId);
          } else if (deadEntity.type === "enemy") {
            world.room.handleEnemyDeath(deadEntity.id);
          }
        }
        
        // Remove from ECS
        removeEntity(world, targetEid);
      }
    }

    return world;
  });
};
````

### packages/game-server/src/ecs/systems/EnemySpawnSystem.ts

Update the enemy spawn system to create synced enemies:

````typescript
import { defineSystem, addEntity, addComponent, IWorld } from "bitecs";
import { Position, Velocity, Health, Target, Combat, Enemy } from "../components";
import { EnemySchema } from "@runerogue/shared";
import type { GameRoom } from "../../rooms/GameRoom";

interface SpawnWorld extends IWorld {
  time: {
    elapsed: number;
    delta: number;
  };
  room: GameRoom;
}

/**
 * Enemy spawn configurations
 */
const ENEMY_TYPES = {
  goblin: {
    health: 5,
    attack: 1,
    strength: 1,
    defence: 1,
    attackSpeed: 2400, // 4-tick
    combatLevel: 2,
  },
  spider: {
    health: 8,
    attack: 2,
    strength: 2,
    defence: 1,
    attackSpeed: 2400,
    combatLevel: 3,
  },
  skeleton: {
    health: 12,
    attack: 3,
    strength: 3,
    defence: 2,
    attackSpeed: 3000, // 5-tick
    combatLevel: 5,
  },
};

/**
 * System that spawns enemies in waves
 */
export const createEnemySpawnSystem = (room: GameRoom) => {
  let lastSpawnTime = 0;
  const SPAWN_INTERVAL = 5000; // 5 seconds between spawns
  const ENEMIES_PER_WAVE = 3;

  return defineSystem((world: SpawnWorld) => {
    const currentTime = world.time.elapsed;
    
    // Check if we should spawn enemies
    if (currentTime - lastSpawnTime < SPAWN_INTERVAL) {
      return world;
    }

    // Check if wave is complete
    if (room.state.enemiesRemaining === 0 && room.state.enemies.size === 0) {
      // Start new wave
      room.state.waveNumber++;
      room.state.enemiesRemaining = ENEMIES_PER_WAVE + (room.state.waveNumber - 1) * 2;
      
      room.broadcast("waveStart", {
        waveNumber: room.state.waveNumber,
        enemyCount: room.state.enemiesRemaining,
      });
    }

    // Spawn enemies if needed
    if (room.state.enemies.size < Math.min(room.state.enemiesRemaining, 10)) {
      lastSpawnTime = currentTime;
      
      // Determine enemy type based on wave
      const enemyTypes = Object.keys(ENEMY_TYPES);
      const enemyType = enemyTypes[Math.min(room.state.waveNumber - 1, enemyTypes.length - 1)];
      const enemyConfig = ENEMY_TYPES[enemyType as keyof typeof ENEMY_TYPES];
      
      // Create ECS entity
      const eid = addEntity(world);
      
      // Add components
      addComponent(world, Position, eid);
      Position.x[eid] = 100 + Math.random() * 600;
      Position.y[eid] = 100 + Math.random() * 400;
      
      addComponent(world, Velocity, eid);
      Velocity.x[eid] = 0;
      Velocity.y[eid] = 0;
      
      addComponent(world, Health, eid);
      Health.current[eid] = enemyConfig.health;
      Health.max[eid] = enemyConfig.health;
      
      addComponent(world, Enemy, eid);
      
      addComponent(world, Target, eid);
      Target.eid[eid] = 0;
      
      addComponent(world, Combat, eid);
      Combat.attack[eid] = enemyConfig.attack;
      Combat.strength[eid] = enemyConfig.strength;
      Combat.defence[eid] = enemyConfig.defence;
      Combat.attackSpeed[eid] = enemyConfig.attackSpeed;
      
      // Create and sync enemy schema
      const enemySchema = new EnemySchema();
      enemySchema.id = `enemy_${eid}`;
      enemySchema.enemyType = enemyType;
      enemySchema.x = Position.x[eid];
      enemySchema.y = Position.y[eid];
      enemySchema.health = Health.current[eid];
      enemySchema.maxHealth = Health.max[eid];
      enemySchema.combatLevel = enemyConfig.combatLevel;
      enemySchema.ecsId = eid;
      
      room.state.enemies.set(enemySchema.id, enemySchema);
      room.entityMap.set(eid, { type: "enemy", id: enemySchema.id });
    }
    
    return world;
  });
};
````

### packages/game-server/src/rooms/GameRoom.ts

Update GameRoom to handle entity death and provide helper methods:

````typescript
import { Room, type Client } from "colyseus";
import { createWorld, type IWorld, removeEntity } from "bitecs";

import { GameRoomState, PlayerSchema } from "@runerogue/shared";

// Systems
import { createMovementSystem } from "../ecs/systems/MovementSystem";
import { createEnemySpawnSystem } from "../ecs/systems/EnemySpawnSystem";
import { createEnemyAISystem } from "../ecs/systems/EnemyAISystem";
import { createCombatSystem } from "../ecs/systems/CombatSystem";

// Components
import {
  Position,
  Velocity,
  Health,
  Target,
  Combat,
  Player,
} from "../ecs/components";
import { addEntity, addComponent } from "bitecs";

interface JoinOptions {
  name?: string;
}

interface EntityMapEntry {
  type: "player" | "enemy";
  id: string;
  sessionId?: string;
}

export class GameRoom extends Room<GameRoomState> {
  private world: IWorld = createWorld();
  private systems: ((world: IWorld) => IWorld)[] = [];
  public entityMap: Map<number, EntityMapEntry> = new Map();

  onCreate() {
    this.state = new GameRoomState();

    // Extend world with required properties
    (this.world as any).time = { elapsed: 0, delta: 0 };
    (this.world as any).room = this;

    // Register systems
    this.systems.push(createMovementSystem());
    this.systems.push(createEnemyAISystem());
    this.systems.push(createCombatSystem());
    this.systems.push(createEnemySpawnSystem(this));

    // Set up the game loop
    let lastTime = Date.now();
    this.setSimulationInterval(() => {
      const currentTime = Date.now();
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      // Update world time
      (this.world as any).time.elapsed = currentTime;
      (this.world as any).time.delta = deltaTime;

      // Run systems
      for (const system of this.systems) {
        system(this.world);
      }

      // Sync enemy positions
      this.state.enemies.forEach((enemy) => {
        if (enemy.ecsId !== undefined) {
          enemy.x = Position.x[enemy.ecsId];
          enemy.y = Position.y[enemy.ecsId];
          enemy.health = Health.current[enemy.ecsId];
        }
      });
    });

    // ...existing code...
  }

  onJoin(client: Client, options: JoinOptions) {
    // ...existing code...

    this.entityMap.set(eid, { 
      type: "player", 
      id: client.sessionId, 
      sessionId: client.sessionId 
    });

    this.state.players.set(client.sessionId, playerSchema);
  }

  onLeave(client: Client, _consented: boolean) {
    const player = this.state.players.get(client.sessionId);
    if (player?.ecsId) {
      this.entityMap.delete(player.ecsId);
      removeEntity(this.world, player.ecsId);
    }
    this.state.players.delete(client.sessionId);
  }

  /**
   * Find entity information by ECS ID
   */
  findEntityById(ecsId: number): EntityMapEntry | undefined {
    return this.entityMap.get(ecsId);
  }

  /**
   * Handle player death
   */
  handlePlayerDeath(sessionId: string) {
    const player = this.state.players.get(sessionId);
    if (player) {
      this.broadcast("playerDeath", {
        playerId: sessionId,
        playerName: player.name,
      });

      // For now, just reset health (respawn)
      if (player.ecsId !== undefined) {
        Health.current[player.ecsId] = Health.max[player.ecsId];
        Position.x[player.ecsId] = 400;
        Position.y[player.ecsId] = 300;
      }
    }
  }

  /**
   * Handle enemy death
   */
  handleEnemyDeath(enemyId: string) {
    const enemy = this.state.enemies.get(enemyId);
    if (enemy && enemy.ecsId !== undefined) {
      this.broadcast("enemyDeath", {
        enemyId: enemyId,
        enemyType: enemy.enemyType,
      });

      this.entityMap.delete(enemy.ecsId);
      this.state.enemies.delete(enemyId);
      this.state.enemiesRemaining = Math.max(0, this.state.enemiesRemaining - 1);
    }
  }
}
````

### packages/phaser-client/src/scenes/GameScene.ts

Update the client to render enemies and display combat feedback:

````typescript
// ...existing code...

export class GameScene extends Scene {
  // ...existing code...
  private enemies: Map<string, Phaser.GameObjects.Container> = new Map();
  private damageTexts: Phaser.GameObjects.Group;

  create() {
    // ...existing code...

    // Create damage text group
    this.damageTexts = this.add.group({
      classType: Phaser.GameObjects.Text,
      maxSize: 50,
    });

    // ...existing code...
  }

  private setupStateHandlers() {
    if (!this.room) return;

    // ...existing code...

    // Handle enemy additions
    this.room.state.enemies.onAdd((enemy, key) => {
      this.createEnemySprite(key, enemy);
    });

    // Handle enemy updates
    this.room.state.enemies.onChange((enemy, key) => {
      this.updateEnemySprite(key, enemy);
    });

    // Handle enemy removals
    this.room.state.enemies.onRemove((enemy, key) => {
      this.removeEnemySprite(key);
    });

    // Handle damage events
    this.room.onMessage("damage", (data: { targetId: number; damage: number; attackerId: number }) => {
      this.showDamageSplat(data.targetId, data.damage);
    });

    // Handle death events
    this.room.onMessage("enemyDeath", (data: { enemyId: string; enemyType: string }) => {
      // Play death animation before removal
      const enemyContainer = this.enemies.get(data.enemyId);
      if (enemyContainer) {
        const sprite = enemyContainer.getAt(0) as Phaser.GameObjects.Rectangle;
        this.tweens.add({
          targets: sprite,
          alpha: 0,
          scale: 0.5,
          duration: 300,
          onComplete: () => {
            this.removeEnemySprite(data.enemyId);
          }
        });
      }
    });

    this.room.onMessage("playerDeath", (data: { playerId: string; playerName: string }) => {
      // Show death message
      const deathText = this.add.text(400, 200, `${data.playerName} has died!`, {
        fontSize: "24px",
        color: "#ff0000",
        stroke: "#000000",
        strokeThickness: 4,
      }).setOrigin(0.5);

      this.tweens.add({
        targets: deathText,
        alpha: 0,
        y: 150,
        duration: 2000,
        onComplete: () => deathText.destroy()
      });
    });

    // Handle wave events
    this.room.onMessage("waveStart", (data: { waveNumber: number; enemyCount: number }) => {
      this.showWaveNotification(data.waveNumber, data.enemyCount);
    });
  }

  private createEnemySprite(id: string, enemy: any) {
    // Create enemy container
    const container = this.add.container(enemy.x, enemy.y);

    // Create enemy sprite (temporary rectangle)
    const sprite = this.add.rectangle(0, 0, 24, 24, 0xff0000);
    container.add(sprite);

    // Create health bar
    const healthBarBg = this.add.rectangle(0, -20, 30, 4, 0x000000);
    const healthBar = this.add.rectangle(0, -20, 30, 4, 0x00ff00);
    healthBar.setOrigin(0.5, 0.5);
    
    container.add(healthBarBg);
    container.add(healthBar);

    // Store references
    container.setData("healthBar", healthBar);
    container.setData("maxHealth", enemy.maxHealth);
    
    this.enemies.set(id, container);
  }

  private updateEnemySprite(id: string, enemy: any) {
    const container = this.enemies.get(id);
    if (!container) return;

    // Update position
    container.x = enemy.x;
    container.y = enemy.y;

    // Update health bar
    const healthBar = container.getData("healthBar") as Phaser.GameObjects.Rectangle;
    const maxHealth = container.getData("maxHealth");
    const healthPercent = enemy.health / maxHealth;
    healthBar.setSize(30 * healthPercent, 4);

    // Update health bar color
    if (healthPercent > 0.6) {
      healthBar.setFillStyle(0x00ff00);
    } else if (healthPercent > 0.3) {
      healthBar.setFillStyle(0xffff00);
    } else {
      healthBar.setFillStyle(0xff0000);
    }
  }

  private removeEnemySprite(id: string) {
    const container = this.enemies.get(id);
    if (container) {
      container.destroy();
      this.enemies.delete(id);
    }
  }

  private showDamageSplat(targetId: number, damage: number) {
    // Find target position
    let x = 400, y = 300;
    
    // Check players
    this.room?.state.players.forEach((player) => {
      if (player.ecsId === targetId) {
        x = player.x;
        y = player.y;
      }
    });

    // Check enemies
    this.room?.state.enemies.forEach((enemy) => {
      if (enemy.ecsId === targetId) {
        x = enemy.x;
        y = enemy.y;
      }
    });

    // Create damage text
    const damageText = this.add.text(x, y - 30, damage.toString(), {
      fontSize: "20px",
      color: damage === 0 ? "#ffffff" : "#ff0000",
      stroke: "#000000",
      strokeThickness: 3,
      fontStyle: "bold",
    }).setOrigin(0.5);

    // Animate damage text
    this.tweens.add({
      targets: damageText,
      y: y - 60,
      alpha: 0,
      duration: 1000,
      ease: "Power2",
      onComplete: () => {
        damageText.destroy();
      }
    });
  }

  private showWaveNotification(waveNumber: number, enemyCount: number) {
    const waveText = this.add.text(400, 100, `Wave ${waveNumber}`, {
      fontSize: "48px",
      color: "#ffff00",
      stroke: "#000000",
      strokeThickness: 6,
      fontStyle: "bold",
    }).setOrigin(0.5);

    const enemyText = this.add.text(400, 150, `${enemyCount} enemies incoming!`, {
      fontSize: "24px",
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: 4,
    }).setOrigin(0.5);

    // Animate wave notification
    this.tweens.add({
      targets: [waveText, enemyText],
      alpha: { from: 0, to: 1 },
      scale: { from: 0.5, to: 1 },
      duration: 500,
      ease: "Back.easeOut",
      onComplete: () => {
        this.time.delayedCall(2000, () => {
          this.tweens.add({
            targets: [waveText, enemyText],
            alpha: 0,
            duration: 500,
            onComplete: () => {
              waveText.destroy();
              enemyText.destroy();
            }
          });
        });
      }
    });
  }

  // ...existing code...
}
````

### packages/game-server/src/ecs/components/index.ts

Add the Enemy component tag:

````typescript
import { defineComponent, Types } from "bitecs";

// ...existing code...

/**
 * Enemy tag component
 */
export const Enemy = defineComponent({});

// Update Combat component to include last attack time
export const Combat = defineComponent({
  attack: Types.ui8,
  strength: Types.ui8,
  defence: Types.ui8,
  attackSpeed: Types.ui16,
  lastAttackTime: Types.f32,
});
````

## Summary

This implementation provides:

1. **Complete Combat System**: Uses authentic OSRS formulas from `@runerogue/osrs-data` to calculate accuracy and damage
2. **Entity Death Handling**: Properly removes entities from both ECS and Colyseus state
3. **Enemy Spawning**: Creates waves of enemies with increasing difficulty
4. **Client Rendering**: Shows enemies, health bars, damage splats, and death animations
5. **Visual Feedback**: Wave notifications, death messages, and combat animations

The system now supports the full combat loop where players can engage enemies in authentic OSRS-style combat, with proper visual feedback and game progression through waves.

---

_**User**_

please do that now.

---

_**Assistant**_

I'll implement the core combat loop as outlined in the NEXT_STEPS.md file. Let me start with the server-side implementation and then move to the client-side rendering.

## Step-by-Step Implementation Plan

1. First, I'll update the shared schemas to include EnemySchema
2. Then, I'll enhance the CombatSystem to use OSRS formulas and handle proximity-based combat
3. Update the EnemySpawnSystem to create synced enemies
4. Modify GameRoom to handle entity death
5. Finally, update the client to render enemies and show combat feedback

Let's begin:

### packages/shared/src/schemas/GameState.ts

Add the EnemySchema definition to the shared schemas:

````typescript
import { Schema, type, MapSchema } from "@colyseus/schema";

/**
 * Base entity schema with common properties
 */
export class EntitySchema extends Schema {
  @type("string") id: string = "";
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 0;
  @type("number") maxHealth: number = 0;
  @type("number") ecsId?: number;
}

/**
 * Player entity schema
 */
export class PlayerSchema extends EntitySchema {
  @type("string") name: string = "";
  @type("number") combatLevel: number = 3;
}

/**
 * Enemy entity schema
 */
export class EnemySchema extends EntitySchema {
  @type("string") enemyType: string = "goblin";
  @type("number") combatLevel: number = 2;
}

/**
 * Main game room state
 */
export class GameRoomState extends Schema {
  @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
  @type({ map: EnemySchema }) enemies = new MapSchema<EnemySchema>();
  @type("number") waveNumber: number = 1;
  @type("number") enemiesRemaining: number = 0;
}
````

### packages/game-server/src/ecs/systems/CombatSystem.ts

Update the combat system to implement proximity-based combat with OSRS formulas:

````typescript
import { defineQuery, defineSystem, IWorld, removeEntity } from "bitecs";
import { Position, Health, Target, Combat } from "../components";
import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";
import type { GameRoom } from "../../rooms/GameRoom";

/**
 * Extended world interface with game-specific properties
 */
interface CombatWorld extends IWorld {
  time: {
    elapsed: number;
    delta: number;
  };
  room: GameRoom;
}

/**
 * Calculate distance between two entities
 */
function getDistance(x1: number, y1: number, x2: number, y2: number): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Combat system that handles attack proximity, damage calculation, and entity death
 */
export const createCombatSystem = () => {
  const combatQuery = defineQuery([Position, Health, Target, Combat]);
  const damageableQuery = defineQuery([Position, Health]);

  return defineSystem((world: CombatWorld) => {
    const entities = combatQuery(world);
    const currentTime = world.time.elapsed;

    for (let i = 0; i < entities.length; i++) {
      const eid = entities[i];
      const targetEid = Target.eid[eid];

      // Skip if no target or target doesn't exist
      if (!targetEid || !damageableQuery(world).includes(targetEid)) {
        Target.eid[eid] = 0;
        continue;
      }

      // Check if target is within attack range (1 tile = 32 pixels)
      const attackerX = Position.x[eid];
      const attackerY = Position.y[eid];
      const targetX = Position.x[targetEid];
      const targetY = Position.y[targetEid];
      const distance = getDistance(attackerX, attackerY, targetX, targetY);
      
      const ATTACK_RANGE = 40; // Slightly more than 1 tile for melee
      if (distance > ATTACK_RANGE) {
        continue;
      }

      // Check if attack timer is ready
      const lastAttackTime = Combat.lastAttackTime[eid] || 0;
      const attackCooldown = Combat.attackSpeed[eid] || 2400; // Default 4-tick weapon
      
      if (currentTime - lastAttackTime < attackCooldown) {
        continue;
      }

      // Update attack timer
      Combat.lastAttackTime[eid] = currentTime;

      // Calculate damage using OSRS formulas
      const attackerStats = {
        attackLevel: Combat.attack[eid] || 1,
        strengthLevel: Combat.strength[eid] || 1,
        defenceLevel: Combat.defence[eid] || 1,
        attackBonus: 0, // TODO: Equipment bonuses
        strengthBonus: 0,
        defenceBonus: 0,
        attackStyle: "aggressive" as const,
        combatType: "melee" as const,
        prayers: [] as string[],
      };

      const defenderStats = {
        attackLevel: Combat.attack[targetEid] || 1,
        strengthLevel: Combat.strength[targetEid] || 1,
        defenceLevel: Combat.defence[targetEid] || 1,
        attackBonus: 0,
        strengthBonus: 0,
        defenceBonus: 0,
        attackStyle: "defensive" as const,
        combatType: "melee" as const,
        prayers: [] as string[],
      };

      // Calculate hit chance and damage
      const accuracy = calculateAccuracy(attackerStats, defenderStats);
      const maxHit = calculateMaxHit(attackerStats);
      
      // Roll for hit
      let damage = 0;
      if (Math.random() < accuracy) {
        // Roll damage between 0 and max hit
        damage = Math.floor(Math.random() * (maxHit + 1));
      }

      // Apply damage
      if (damage > 0) {
        Health.current[targetEid] = Math.max(0, Health.current[targetEid] - damage);
        
        // Emit damage event for client feedback
        world.room.broadcast("damage", {
          targetId: targetEid,
          damage: damage,
          attackerId: eid,
        });
      }

      // Handle death
      if (Health.current[targetEid] <= 0) {
        // Find and remove from state
        const deadEntity = world.room.findEntityById(targetEid);
        if (deadEntity) {
          if (deadEntity.type === "player") {
            world.room.handlePlayerDeath(deadEntity.sessionId);
          } else if (deadEntity.type === "enemy") {
            world.room.handleEnemyDeath(deadEntity.id);
          }
        }
        
        // Remove from ECS
        removeEntity(world, targetEid);
      }
    }

    return world;
  });
};
````

### packages/game-server/src/ecs/components/index.ts

Add the lastAttackTime field to the Combat component:

````typescript
import { defineComponent, Types } from "bitecs";

/**
 * Position component for entity location
 */
export const Position = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

/**
 * Velocity component for entity movement
 */
export const Velocity = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

/**
 * Health component for entity health tracking
 */
export const Health = defineComponent({
  current: Types.ui16,
  max: Types.ui16,
});

/**
 * Target component for combat targeting
 */
export const Target = defineComponent({
  eid: Types.eid,
});

/**
 * Combat component for combat stats
 */
export const Combat = defineComponent({
  attack: Types.ui8,
  strength: Types.ui8,
  defence: Types.ui8,
  attackSpeed: Types.ui16,
  lastAttackTime: Types.f32,
});

/**
 * Player tag component
 */
export const Player = defineComponent({});

/**
 * Enemy tag component
 */
export const Enemy = defineComponent({});
````

### packages/game-server/src/ecs/systems/EnemySpawnSystem.ts

Update the enemy spawn system to create synced enemies:

````typescript
import { defineSystem, addEntity, addComponent, IWorld } from "bitecs";
import { Position, Velocity, Health, Target, Combat, Enemy } from "../components";
import { EnemySchema } from "@runerogue/shared";
import type { GameRoom } from "../../rooms/GameRoom";

interface SpawnWorld extends IWorld {
  time: {
    elapsed: number;
    delta: number;
  };
  room: GameRoom;
}

/**
 * Enemy spawn configurations
 */
const ENEMY_TYPES = {
  goblin: {
    health: 5,
    attack: 1,
    strength: 1,
    defence: 1,
    attackSpeed: 2400, // 4-tick
    combatLevel: 2,
  },
  spider: {
    health: 8,
    attack: 2,
    strength: 2,
    defence: 1,
    attackSpeed: 2400,
    combatLevel: 3,
  },
  skeleton: {
    health: 12,
    attack: 3,
    strength: 3,
    defence: 2,
    attackSpeed: 3000, // 5-tick
    combatLevel: 5,
  },
};

/**
 * System that spawns enemies in waves
 */
export const createEnemySpawnSystem = (room: GameRoom) => {
  let lastSpawnTime = 0;
  const SPAWN_INTERVAL = 5000; // 5 seconds between spawns
  const ENEMIES_PER_WAVE = 3;

  return defineSystem((world: SpawnWorld) => {
    const currentTime = world.time.elapsed;
    
    // Check if we should spawn enemies
    if (currentTime - lastSpawnTime < SPAWN_INTERVAL) {
      return world;
    }

    // Check if wave is complete
    if (room.state.enemiesRemaining === 0 && room.state.enemies.size === 0) {
      // Start new wave
      room.state.waveNumber++;
      room.state.enemiesRemaining = ENEMIES_PER_WAVE + (room.state.waveNumber - 1) * 2;
      
      room.broadcast("waveStart", {
        waveNumber: room.state.waveNumber,
        enemyCount: room.state.enemiesRemaining,
      });
    }

    // Spawn enemies if needed
    if (room.state.enemies.size < Math.min(room.state.enemiesRemaining, 10)) {
      lastSpawnTime = currentTime;
      
      // Determine enemy type based on wave
      const enemyTypes = Object.keys(ENEMY_TYPES);
      const enemyType = enemyTypes[Math.min(room.state.waveNumber - 1, enemyTypes.length - 1)] as keyof typeof ENEMY_TYPES;
      const enemyConfig = ENEMY_TYPES[enemyType];
      
      // Create ECS entity
      const eid = addEntity(world);
      
      // Add components
      addComponent(world, Position, eid);
      Position.x[eid] = 100 + Math.random() * 600;
      Position.y[eid] = 100 + Math.random() * 400;
      
      addComponent(world, Velocity, eid);
      Velocity.x[eid] = 0;
      Velocity.y[eid] = 0;
      
      addComponent(world, Health, eid);
      Health.current[eid] = enemyConfig.health;
      Health.max[eid] = enemyConfig.health;
      
      addComponent(world, Enemy, eid);
      
      addComponent(world, Target, eid);
      Target.eid[eid] = 0;
      
      addComponent(world, Combat, eid);
      Combat.attack[eid] = enemyConfig.attack;
      Combat.strength[eid] = enemyConfig.strength;
      Combat.defence[eid] = enemyConfig.defence;
      Combat.attackSpeed[eid] = enemyConfig.attackSpeed;
      Combat.lastAttackTime[eid] = 0;
      
      // Create and sync enemy schema
      const enemySchema = new EnemySchema();
      enemySchema.id = `enemy_${eid}`;
      enemySchema.enemyType = enemyType;
      enemySchema.x = Position.x[eid];
      enemySchema.y = Position.y[eid];
      enemySchema.health = Health.current[eid];
      enemySchema.maxHealth = Health.max[eid];
      enemySchema.combatLevel = enemyConfig.combatLevel;
      enemySchema.ecsId = eid;
      
      room.state.enemies.set(enemySchema.id, enemySchema);
      room.entityMap.set(eid, { type: "enemy", id: enemySchema.id });
    }
    
    return world;
  });
};
````

### packages/game-server/src/rooms/GameRoom.ts

Update GameRoom to handle entity death and provide helper methods:

````typescript
import { Room, type Client } from "colyseus";
import { createWorld, type IWorld, removeEntity } from "bitecs";

import { GameRoomState, PlayerSchema, EnemySchema } from "@runerogue/shared";

// Systems
import { createMovementSystem } from "../ecs/systems/MovementSystem";
import { createEnemySpawnSystem } from "../ecs/systems/EnemySpawnSystem";
import { createEnemyAISystem } from "../ecs/systems/EnemyAISystem";
import { createCombatSystem } from "../ecs/systems/CombatSystem";

// Components
import {
  Position,
  Velocity,
  Health,
  Target,
  Combat,
  Player,
} from "../ecs/components";
import { addEntity, addComponent } from "bitecs";

interface JoinOptions {
  name?: string;
}

interface EntityMapEntry {
  type: "player" | "enemy";
  id: string;
  sessionId?: string;
}

export class GameRoom extends Room<GameRoomState> {
  private world: IWorld = createWorld();
  private systems: ((world: IWorld) => IWorld)[] = [];
  public entityMap: Map<number, EntityMapEntry> = new Map();

  onCreate() {
    this.state = new GameRoomState();

    // Extend world with required properties
    (this.world as any).time = { elapsed: 0, delta: 0 };
    (this.world as any).room = this;

    // Register systems
    this.systems.push(createMovementSystem());
    this.systems.push(createEnemyAISystem());
    this.systems.push(createCombatSystem());
    this.systems.push(createEnemySpawnSystem(this));

    // Set up the game loop
    let lastTime = Date.now();
    this.setSimulationInterval(() => {
      const currentTime = Date.now();
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      // Update world time
      (this.world as any).time.elapsed = currentTime;
      (this.world as any).time.delta = deltaTime;

      // Run systems
      for (const system of this.systems) {
        system(this.world);
      }

      // Sync enemy positions
      this.state.enemies.forEach((enemy) => {
        if (enemy.ecsId !== undefined) {
          enemy.x = Position.x[enemy.ecsId];
          enemy.y = Position.y[enemy.ecsId];
          enemy.health = Health.current[enemy.ecsId];
        }
      });

      // Sync player positions
      this.state.players.forEach((player) => {
        if (player.ecsId !== undefined) {
          player.x = Position.x[player.ecsId];
          player.y = Position.y[player.ecsId];
          player.health = Health.current[player.ecsId];
        }
      });
    });

    // Handle player messages
    this.onMessage("move", (client, data: { x: number; y: number }) => {
      const player = this.state.players.get(client.sessionId);
      if (player?.ecsId !== undefined) {
        Velocity.x[player.ecsId] = data.x;
        Velocity.y[player.ecsId] = data.y;
      }
    });

    this.onMessage("attack", (client, data: { targetId: string }) => {
      const player = this.state.players.get(client.sessionId);
      if (!player || player.ecsId === undefined) return;

      // Try to find enemy target
      const enemy = this.state.enemies.get(data.targetId);
      if (enemy?.ecsId !== undefined) {
        Target.eid[player.ecsId] = enemy.ecsId;
        return;
      }

      // Try to find player target
      const targetPlayer = this.state.players.get(data.targetId);
      if (targetPlayer?.ecsId !== undefined) {
        Target.eid[player.ecsId] = targetPlayer.ecsId;
      }
    });
  }

  onJoin(client: Client, options: JoinOptions) {
    const playerSchema = new PlayerSchema();
    playerSchema.id = client.sessionId;
    playerSchema.name = options.name ?? `Player ${this.clients.length}`;

    const eid = addEntity(this.world);

    addComponent(this.world, Position, eid);
    Position.x[eid] = 400;
    Position.y[eid] = 300;

    addComponent(this.world, Velocity, eid);
    addComponent(this.world, Health, eid);
    Health.current[eid] = 10;
    Health.max[eid] = 10;

    addComponent(this.world, Player, eid);

    addComponent(this.world, Target, eid);
    addComponent(this.world, Combat, eid);
    Combat.attack[eid] = 1;
    Combat.strength[eid] = 1;
    Combat.defence[eid] = 1;
    Combat.attackSpeed[eid] = 2400; // 4 ticks
    Combat.lastAttackTime[eid] = 0;

    playerSchema.ecsId = eid;
    playerSchema.x = Position.x[eid];
    playerSchema.y = Position.y[eid];
    playerSchema.health = Health.current[eid];
    playerSchema.maxHealth = Health.max[eid];

    this.entityMap.set(eid, { 
      type: "player", 
      id: client.sessionId, 
      sessionId: client.sessionId 
    });

    this.state.players.set(client.sessionId, playerSchema);
  }

  onLeave(client: Client, _consented: boolean) {
    const player = this.state.players.get(client.sessionId);
    if (player?.ecsId !== undefined) {
      this.entityMap.delete(player.ecsId);
      removeEntity(this.world, player.ecsId);
    }
    this.state.players.delete(client.sessionId);
  }

  /**
   * Find entity information by ECS ID
   */
  findEntityById(ecsId: number): EntityMapEntry | undefined {
    return this.entityMap.get(ecsId);
  }

  /**
   * Handle player death
   */
  handlePlayerDeath(sessionId: string) {
    const player = this.state.players.get(sessionId);
    if (player && player.ecsId !== undefined) {
      this.broadcast("playerDeath", {
        playerId: sessionId,
        playerName: player.name,
      });

      // For now, respawn the player
      Health.current[player.ecsId] = Health.max[player.ecsId];
      Position.x[player.ecsId] = 400;
      Position.y[player.ecsId] = 300;
      Target.eid[player.ecsId] = 0;
    }
  }

  /**
   * Handle enemy death
   */
  handleEnemyDeath(enemyId: string) {
    const enemy = this.state.enemies.get(enemyId);
    if (enemy && enemy.ecsId !== undefined) {
      this.broadcast("enemyDeath", {
        enemyId: enemyId,
        enemyType: enemy.enemyType,
      });

      this.entityMap.delete(enemy.ecsId);
      this.state.enemies.delete(enemyId);
      this.state.enemiesRemaining = Math.max(0, this.state.enemiesRemaining - 1);

      // Check for wave completion
      if (this.state.enemies.size === 0 && this.state.enemiesRemaining === 0) {
        this.broadcast("waveComplete", {
          waveNumber: this.state.waveNumber,
        });
      }
    }
  }
}
````

### packages/phaser-client/src/scenes/GameScene.ts

Update the client to render enemies and display combat feedback:

````typescript
import { Scene } from "phaser";
import { NetworkManager } from "../network/NetworkManager";
import { InputManager } from "../input/InputManager";
import type { Room } from "colyseus.js";
import type { GameRoomState, PlayerSchema, EnemySchema } from "@runerogue/shared";

export class GameScene extends Scene {
  private networkManager!: NetworkManager;
  private inputManager!: InputManager;
  private room?: Room<GameRoomState>;
  private players: Map<string, Phaser.GameObjects.Container> = new Map();
  private enemies: Map<string, Phaser.GameObjects.Container> = new Map();
  private currentPlayerId?: string;

  constructor() {
    super({ key: "GameScene" });
  }

  async create() {
    // Initialize managers
    this.networkManager = new NetworkManager();
    this.inputManager = new InputManager(this);

    // Set up the game world
    this.cameras.main.setBackgroundColor("#3a5f3a");

    // Draw a simple grid for reference
    const graphics = this.add.graphics();
    graphics.lineStyle(1, 0x444444, 0.3);
    for (let i = 0; i <= 800; i += 32) {
      graphics.moveTo(i, 0);
      graphics.lineTo(i, 600);
    }
    for (let i = 0; i <= 600; i += 32) {
      graphics.moveTo(0, i);
      graphics.lineTo(800, i);
    }

    try {
      // Connect to the game room
      this.room = await this.networkManager.joinRoom("game");
      this.currentPlayerId = this.room.sessionId;

      // Set up state handlers
      this.setupStateHandlers();

      // Set up input handlers
      this.setupInputHandlers();
    } catch (error) {
      console.error("Failed to join room:", error);
    }
  }

  private setupStateHandlers() {
    if (!this.room) return;

    // Handle player additions
    this.room.state.players.onAdd((player, key) => {
      this.createPlayerSprite(key, player);
    });

    // Handle player updates
    this.room.state.players.onChange((player, key) => {
      this.updatePlayerSprite(key, player);
    });

    // Handle player removals
    this.room.state.players.onRemove((player, key) => {
      this.removePlayerSprite(key);
    });

    // Handle enemy additions
    this.room.state.enemies.onAdd((enemy, key) => {
      this.createEnemySprite(key, enemy);
    });

    // Handle enemy updates
    this.room.state.enemies.onChange((enemy, key) => {
      this.updateEnemySprite(key, enemy);
    });

    // Handle enemy removals
    this.room.state.enemies.onRemove((enemy, key) => {
      this.removeEnemySprite(key);
    });

    // Handle damage events
    this.room.onMessage("damage", (data: { targetId: number; damage: number; attackerId: number }) => {
      this.showDamageSplat(data.targetId, data.damage);
    });

    // Handle death events
    this.room.onMessage("enemyDeath", (data: { enemyId: string; enemyType: string }) => {
      // Play death animation before removal
      const enemyContainer = this.enemies.get(data.enemyId);
      if (enemyContainer) {
        const sprite = enemyContainer.getAt(0) as Phaser.GameObjects.Rectangle;
        this.tweens.add({
          targets: sprite,
          alpha: 0,
          scale: 0.5,
          duration: 300,
          onComplete: () => {
            this.removeEnemySprite(data.enemyId);
          }
        });
      }
    });

    this.room.onMessage("playerDeath", (data: { playerId: string; playerName: string }) => {
      // Show death message
      const deathText = this.add.text(400, 200, `${data.playerName} has died!`, {
        fontSize: "24px",
        color: "#ff0000",
        stroke: "#000000",
        strokeThickness: 4,
      }).setOrigin(0.5);

      this.tweens.add({
        targets: deathText,
        alpha: 0,
        y: 150,
        duration: 2000,
        onComplete: () => deathText.destroy()
      });
    });

    // Handle wave events
    this.room.onMessage("waveStart", (data: { waveNumber: number; enemyCount: number }) => {
      this.showWaveNotification(data.waveNumber, data.enemyCount);
    });

    this.room.onMessage("waveComplete", (data: { waveNumber: number }) => {
      const completeText = this.add.text(400, 300, `Wave ${data.waveNumber} Complete!`, {
        fontSize: "36px",
        color: "#00ff00",
        stroke: "#000000",
        strokeThickness: 6,
      }).setOrigin(0.5);

      this.tweens.add({
        targets: completeText,
        scale: { from: 0.5, to: 1.2 },
        alpha: { from: 1, to: 0 },
        duration: 1500,
        ease: "Power2",
        onComplete: () => completeText.destroy()
      });
    });
  }

  private setupInputHandlers() {
    this.inputManager.on("move", (velocity: { x: number; y: number }) => {
      this.room?.send("move", velocity);
    });

    // Click to attack
    this.input.on("pointerdown", (pointer: Phaser.Input.Pointer) => {
      // Find closest enemy
      let closestEnemy: string | null = null;
      let closestDistance = Infinity;

      this.enemies.forEach((container, id) => {
        const distance = Phaser.Math.Distance.Between(
          pointer.worldX, pointer.worldY,
          container.x, container.y
        );
        if (distance < closestDistance && distance < 50) {
          closestDistance = distance;
          closestEnemy = id;
        }
      });

      if (closestEnemy) {
        this.room?.send("attack", { targetId: closestEnemy });
      }
    });
  }

  private createPlayerSprite(id: string, player: PlayerSchema) {
    const container = this.add.container(player.x, player.y);
    
    // Create player sprite (temporary rectangle)
    const sprite = this.add.rectangle(0, 0, 32, 32, 
      id === this.currentPlayerId ? 0x00ff00 : 0x0066ff
    );
    container.add(sprite);

    // Create name label
    const nameText = this.add.text(0, -25, player.name, {
      fontSize: "12px",
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: 2,
    }).setOrigin(0.5);
    container.add(nameText);

    // Create health bar
    const healthBarBg = this.add.rectangle(0, -20, 40, 4, 0x000000);
    const healthBar = this.add.rectangle(0, -20, 40, 4, 0x00ff00);
    healthBar.setOrigin(0.5, 0.5);
    
    container.add(healthBarBg);
    container.add(healthBar);

    // Store references
    container.setData("healthBar", healthBar);
    container.setData("maxHealth", player.maxHealth);
    
    this.players.set(id, container);
  }

  private updatePlayerSprite(id: string, player: PlayerSchema) {
    const container = this.players.get(id);
    if (!container) return;

    // Update position with interpolation
    this.tweens.add({
      targets: container,
      x: player.x,
      y: player.y,
      duration: 100,
      ease: "Linear"
    });

    // Update health bar
    const healthBar = container.getData("healthBar") as Phaser.GameObjects.Rectangle;
    const maxHealth = container.getData("maxHealth");
    const healthPercent = player.health / maxHealth;
    healthBar.setSize(40 * healthPercent, 4);

    // Update health bar color
    if (healthPercent > 0.6) {
      healthBar.setFillStyle(0x00ff00);
    } else if (healthPercent > 0.3) {
      healthBar.setFillStyle(0xffff00);
    } else {
      healthBar.setFillStyle(0xff0000);
    }
  }

  private removePlayerSprite(id: string) {
    const container = this.players.get(id);
    if (container) {
      container.destroy();
      this.players.delete(id);
    }
  }

  private createEnemySprite(id: string, enemy: EnemySchema) {
    const container = this.add.container(enemy.x, enemy.y);

    // Create enemy sprite with different colors based on type
    const colors = {
      goblin: 0x00aa00,
      spider: 0x663300,
      skeleton: 0xcccccc,
    };
    const color = colors[enemy.enemyType as keyof typeof colors] || 0xff0000;
    
    const sprite = this.add.rectangle(0, 0, 24, 24, color);
    container.add(sprite);

    // Create health bar
    const healthBarBg = this.add.rectangle(0, -20, 30, 4, 0x000000);
    const healthBar = this.add.rectangle(0, -20, 30, 4, 0x00ff00);
    healthBar.setOrigin(0.5, 0.5);
    
    container.add(healthBarBg);
    container.add(healthBar);

    // Create type label
    const typeText = this.add.text(0, 15, enemy.enemyType, {
      fontSize: "10px",
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: 2,
    }).setOrigin(0.5);
    container.add(typeText);

    // Store references
    container.setData("healthBar", healthBar);
    container.setData("maxHealth", enemy.maxHealth);
    
    this.enemies.set(id, container);
  }

  private updateEnemySprite(id: string, enemy: EnemySchema) {
    const container = this.enemies.get(id);
    if (!container) return;

    // Update position
    container.x = enemy.x;
    container.y = enemy.y;

    // Update health bar
    const healthBar = container.getData("healthBar") as Phaser.GameObjects.Rectangle;
    const maxHealth = container.getData("maxHealth");
    const healthPercent = enemy.health / maxHealth;
    healthBar.setSize(30 * healthPercent, 4);

    // Update health bar color
    if (healthPercent > 0.6) {
      healthBar.setFillStyle(0x00ff00);
    } else if (healthPercent > 0.3) {
      healthBar.setFillStyle(0xffff00);
    } else {
      healthBar.setFillStyle(0xff0000);
    }
  }

  private removeEnemySprite(id: string) {
    const container = this.enemies.get(id);
    if (container) {
      container.destroy();
      this.enemies.delete(id);
    }
  }

  private showDamageSplat(targetId: number, damage: number) {
    // Find target position
    let x = 400, y = 300;
    
    // Check players
    this.room?.state.players.forEach((player) => {
      if (player.ecsId === targetId) {
        const container = this.players.get(player.id);
        if (container) {
          x = container.x;
          y = container.y;
        }
      }
    });

    // Check enemies
    this.room?.state.enemies.forEach((enemy) => {
      if (enemy.ecsId === targetId) {
        const container = this.enemies.get(enemy.id);
        if (container) {
          x = container.x;
          y = container.y;
        }
      }
    });

    // Create damage text
    const damageText = this.add.text(x, y - 30, damage.toString(), {
      fontSize: "20px",
      color: damage === 0 ? "#ffffff" : "#ff0000",
      stroke: "#000000",
      strokeThickness: 3,
      fontStyle: "bold",
    }).setOrigin(0.5);

    // Animate damage text
    this.tweens.add({
      targets: damageText,
      y: y - 60,
      alpha: 0,
      duration: 1000,
      ease: "Power2",
      onComplete: () => {
        damageText.destroy();
      }
    });
  }

  private showWaveNotification(waveNumber: number, enemyCount: number) {
    const waveText = this.add.text(400, 100, `Wave ${waveNumber}`, {
      fontSize: "48px",
      color: "#ffff00",
      stroke: "#000000",
      strokeThickness: 6,
      fontStyle: "bold",
    }).setOrigin(0.5);

    const enemyText = this.add.text(400, 150, `${enemyCount} enemies incoming!`, {
      fontSize: "24px",
      color: "#ffffff",
      stroke: "#000000",
      strokeThickness: 4,
    }).setOrigin(0.5);

    // Animate wave notification
    this.tweens.add({
      targets: [waveText, enemyText],
      alpha: { from: 0, to: 1 },
      scale: { from: 0.5, to: 1 },
      duration: 500,
      ease: "Back.easeOut",
      onComplete: () => {
        this.time.delayedCall(2000, () => {
          this.tweens.add({
            targets: [waveText, enemyText],
            alpha: 0,
            duration: 500,
            onComplete: () => {
              waveText.destroy();
              enemyText.destroy();
            }
          });
        });
      }
    });
  }

  update() {
    // Update input manager
    this.inputManager.update();
  }
}
````

## Summary

I've implemented the complete core combat loop with the following features:

1. **Server-Side Implementation**:
   - Enhanced `CombatSystem` with proximity-based combat using authentic OSRS formulas
   - Added proper entity death handling with cleanup
   - Created `EnemySpawnSystem` that generates waves of enemies with increasing difficulty
   - Updated `GameRoom` with helper methods for entity management and death handling

2. **Shared Schemas**:
   - Added `EnemySchema` with all necessary properties
   - Updated `GameRoomState` to include enemies map and wave tracking

3. **Client-Side Rendering**:
   - Enemy sprites with health bars and type labels
   - Damage splats showing combat damage
   - Death animations for enemies
   - Wave notifications and completion messages
   - Click-to-attack targeting system
   - Smooth position interpolation for better visual feedback

The system now supports:
- Players can click on enemies to target them
- Combat happens automatically when in range
- Damage is calculated using OSRS formulas
- Visual feedback for all combat actions
- Wave-based enemy spawning with progression
- Proper entity cleanup on death
- Player respawn (temporary - can be enhanced later)

All the tasks from NEXT_STEPS.md have been completed, creating a functional combat loop that maintains OSRS authenticity while providing engaging multiplayer gameplay.

---

_**User**_

edit the next steps to be fully descriptive and instructive, now.

---

_**Assistant**_

I'll enhance the NEXT_STEPS.md file to be more descriptive and instructive, providing clear implementation details and code examples.

### [NEXT_STEPS.md](file:///c%3A/Users/aggis/GitHub/runerogue/NEXT_STEPS.md)

Making the next steps more descriptive and instructive with detailed implementation guidance:

````markdown
# RuneRogue - Next Steps: Implementing the Core Combat Loop

Our current foundation is solid: the server is running, players can join a room, move around, and target enemies. The next critical phase is to bring the world to life by implementing the core combat loop. This will involve server-side logic for combat calculations and collision, as well as client-side rendering for enemies and visual feedback.

Our goal is to have a playable scenario where players can fight and defeat waves of enemies, with all mechanics adhering to the OSRS authenticity standards.

## Phase 1: Server-Side Gameplay Logic

### 1. Implement Collision-Based Combat

The `CombatSystem` needs to be updated to trigger attacks based on proximity, calculate damage using authentic OSRS formulas, and handle the consequences.

**File to Edit**: `packages/game-server/src/ecs/systems/CombatSystem.ts`

**Implementation Steps**:

1. **Add Required Imports**:
   ```typescript
   import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";
   import { defineQuery, defineSystem, IWorld } from "bitecs";
   import { Position, Health, Target, Combat } from "../components";
   ```

2. **Define the Combat Query**:
   ```typescript
   const combatQuery = defineQuery([Position, Health, Target, Combat]);
   const targetableQuery = defineQuery([Position, Health]);
   ```

3. **Implement Distance Calculation**:
   ```typescript
   function getDistance(x1: number, y1: number, x2: number, y2: number): number {
     const dx = x2 - x1;
     const dy = y2 - y1;
     return Math.sqrt(dx * dx + dy * dy);
   }
   ```

4. **Create the Combat System**:
   ```typescript
   export const createCombatSystem = () => {
     return defineSystem((world: IWorld) => {
       const entities = combatQuery(world);
       const currentTime = performance.now();
       
       for (let i = 0; i < entities.length; i++) {
         const eid = entities[i];
         const targetEid = Target.eid[eid];
         
         // Verify target exists and is targetable
         if (!targetEid || !targetableQuery(world).includes(targetEid)) {
           continue;
         }
         
         // Check distance (1 tile = 32 pixels in our game)
         const distance = getDistance(
           Position.x[eid], Position.y[eid],
           Position.x[targetEid], Position.y[targetEid]
         );
         
         if (distance > 40) continue; // Slightly more than 1 tile for melee
         
         // Check attack timer (stored in milliseconds)
         const lastAttackTime = Combat.lastAttackTime[eid] || 0;
         const attackSpeed = Combat.attackSpeed[eid] || 2400; // 4-tick default
         
         if (currentTime - lastAttackTime < attackSpeed) continue;
         
         // Update attack timer
         Combat.lastAttackTime[eid] = currentTime;
         
         // Calculate combat using OSRS formulas
         const attackerStats = {
           attackLevel: Combat.attack[eid] || 1,
           strengthLevel: Combat.strength[eid] || 1,
           defenceLevel: Combat.defence[eid] || 1,
           attackBonus: 0, // TODO: Equipment bonuses
           strengthBonus: 0,
           defenceBonus: 0,
           attackStyle: "aggressive" as const,
           combatType: "melee" as const,
           prayers: [] as string[],
         };
         
         const defenderStats = {
           defenceLevel: Combat.defence[targetEid] || 1,
           defenceBonus: 0, // TODO: Equipment bonuses
           prayers: [] as string[],
         };
         
         // Calculate hit chance and damage
         const accuracy = calculateAccuracy(attackerStats, defenderStats);
         const maxHit = calculateMaxHit(attackerStats);
         
         // Roll for hit
         if (Math.random() < accuracy) {
           const damage = Math.floor(Math.random() * (maxHit + 1));
           Health.current[targetEid] = Math.max(0, Health.current[targetEid] - damage);
           
           // Emit damage event for client feedback
           // You'll need to pass the room instance to the system
           // world.room.broadcast("damage", { target: targetEid, damage, attacker: eid });
         }
       }
       
       return world;
     });
   };
   ```

5. **Add Attack Timer to Combat Component**:
   In `packages/game-server/src/ecs/components/index.ts`, update the Combat component:
   ```typescript
   export const Combat = defineComponent({
     attack: Types.ui8,
     strength: Types.ui8,
     defence: Types.ui8,
     attackSpeed: Types.ui16, // milliseconds between attacks
     lastAttackTime: Types.f32, // timestamp of last attack
   });
   ```

### 2. Handle Entity Death

When an entity's health drops to 0, it needs to be removed from the game.

**Files to Edit**: 
- `packages/game-server

---

