<!-- Generated by SpecStory -->

# RuneRogue Development Prompt: Phase 2 - AI, Death, (2025-06-18 11:43:53)

_**User**_

RuneRogue Development Prompt: Phase 2 - AI, Death, and Polish
Goal: Evolve the server-authoritative combat loop by implementing enemy AI, handling player and enemy death, and adding critical visual and audio feedback to create a dynamic and engaging gameplay experience.

Current State Analysis: The project has successfully established a server-authoritative combat foundation. Clients send attack intents, the server calculates OSRS-accurate damage, and the state is synchronized back to all players. Basic UI feedback, including health bars and damage splats, is functional.

Key Limitations to Address:

Passive Enemies: Enemies are currently static targets. They do not react to or engage with players, posing no actual threat.
No Consequences: There are no mechanics for handling what happens when an entity's health reaches zero. Both players and enemies are effectively immortal.
Lack of Game Feel: The combat interaction feels sterile due to the absence of animations and sound effects.
State Management: The Player and Enemy schemas may have redundant fields that could be better organized through composition.
Architectural Mandate (from documentation):

Server Authority: The server remains the single source of truth for all game logic, including AI behavior and life/death states.
OSRS Authenticity: Enemy attack speeds and behavior should feel authentic to OSRS.
ECS Design: New logic must be encapsulated in modular, data-oriented systems.
Phase 1: Enemy AI and Aggression
The server must control enemy behavior, making them an active threat to players.

Tasks:

Implement EnemyAISystem: Create a new server-side ECS system in the game-server package (packages/game-server/src/ecs/systems/EnemyAISystem.ts). This system will be responsible for all enemy decision-making.
Aggression: The system should periodically scan for players within a defined aggression radius for each enemy.
Targeting: When a player enters this radius, the enemy should "aggro" onto them, storing the player's entity ID as its current target.
Pathfinding & Movement: The enemy should move towards its targeted player.
Attacking: Once in melee range, the enemy must automatically initiate an attack against the player. This server-initiated attack should reuse the existing combat calculation logic.
Enemy Attack Cooldown: Ensure enemies respect OSRS attack speeds. Implement a lastAttackTick component or a similar mechanism for enemies to prevent them from attacking on every server tick.
Schema Updates: Add any necessary components to the Enemy schema, such as targetId or an AIState (e.g., 'IDLE', 'ATTACKING').
Phase 2: Life, Death, and Consequences
Entities must be removed from the game upon death, and players need a respawn mechanism.

Tasks:

Create DeathSystem: Implement a new server-side ECS system (packages/game-server/src/ecs/systems/DeathSystem.ts).
This system will query for any entity whose health has reached zero.
Enemy Death: When an enemy dies, the server should remove it from the game state. To allow time for a death animation, the removal should be slightly delayed.
Player Death: When a player dies, their state should be updated to isDead: true. They should not be removed. After a 5-second timer, the server should respawn them at the starting location with full health.
Broadcast Death Events: The server must notify clients when an entity dies so they can play the appropriate visual effects. A new message, such as room.send("entityDied", { entityId, isPlayer }), should be broadcast.
Client-Side Death Handling: In GameScene.ts, listen for the entityDied message. When received, trigger a death animation on the corresponding sprite and then remove it from the scene (if it's an enemy).
Phase 3: Polish and Game Feel
Enhance the user experience with better visual and audio feedback to make combat feel impactful.

Tasks:

Attack Animations:
On the client, create a new AnimationSystem (packages/phaser-client/src/ecs/systems/AnimationSystem.ts).
When an attack occurs (triggered by the player's input or a server message for an enemy attack), this system should play the correct attack animation on the character's sprite.
Sound Effects:
Integrate an audio manager on the client.
Play sound effects for weapon swings, successful hits (based on damage splat creation), and taking damage.
Refine Damage Splats:
In damageSplatSystem.ts, differentiate the appearance of damage splats. Player damage dealt to enemies should be red, while damage taken by the player should be a different color (e.g., blue or orange). A "miss" (0 damage) should also have a distinct visual.
Phase 4: Code Refinement and Testing
Ensure the new systems are robust, maintainable, and well-tested.

Tasks:

Component Refactoring: Review the Player and Enemy schemas in RuneRogueState.ts. Abstract shared properties (like health, combatStats, position) into a reusable Character base schema or through composition to reduce code duplication and improve maintainability.
Write Unit & Integration Tests:
Add tests for the EnemyAISystem to validate aggression radius, targeting, and attack initiation.
Add tests for the DeathSystem to confirm that entities are correctly removed or respawned when their health reaches zero.
Acceptance Criteria:

Enemies autonomously engage and attack players who enter their aggression range.
Player and enemy death is handled gracefully: enemies are removed, and players respawn.
Attack, death, and damage events are accompanied by corresponding animations and sound effects.
The server-side schemas are refactored to be more modular and reusable.
The new systems are covered by automated tests.

---

_**Assistant**_

Okay, I will start by implementing Phase 1: Enemy AI and Aggression. First, I need to understand the existing ECS structure. I'll begin by listing the current systems in the `game-server` package. I will start by exploring the existing game server code to understand the current structure before implementing the new features. I'll begin with listing the contents of the `` directory. I will start by setting up the necessary directories and files for the new systems. First, I'll create the `systems` directory for the server-side ECS. Okay, I will start by implementing Phase 1: Enemy AI and Aggression. This involves creating a new `EnemyAISystem` on the server, which will handle enemy behavior, including aggression, targeting, movement, and attacking. I will also update the necessary schemas to support this new logic.

First, I need to see the existing schema files to understand the current state structure. Okay, I will start by creating the `EnemyAISystem.ts` and `DeathSystem.ts` files. Then, I will refactor the `RuneRogueState.ts` to improve the schema composition. After that, I will implement the `EnemyAISystem.ts` and `DeathSystem.ts`, and then I will update the `GameRoom.ts` to include the new systems. Finally, I will move on to the client-side changes.

I will now read the `GameState.ts` file to understand the current state structure. Okay, let's get started on Phase 2. This is a big update that will bring the game to life with enemy AI, death mechanics, and much-needed polish. I'll tackle this in the order you've specified.

### Phase 4 (Part 1): Code Refinement

Before adding new features, I'll start with the requested refactoring. A solid foundation is key. I'm refactoring the `Player` and `Enemy` schemas in `GameState.ts` to reduce duplication. I'll introduce a `Character` base schema to hold common properties like position, health, and combat stats. This will make the code cleaner and easier to maintain.

 
````

````
Okay, the schemas have been refactored. Now, let's get to the core of the request, starting with the enemy AI.

I will create the `EnemyAISystem.ts` file inside ``. This system will handle the enemy's aggression, targeting, and attacking logic as requested. I'll start with a basic implementation that finds the nearest player and moves the enemy toward them, initiating an attack when in range. I'll also make sure to respect OSRS attack timings. Okay, I will begin by implementing the server-side changes for enemy AI and death mechanics.

First, I've refactored the schemas in `GameState.ts` to use a `Character` base class. This improves maintainability by reducing code duplication. I've also added the `isDead` flag to the `Player` schema and an `aiState` to the `Enemy` schema to support the new systems.

Next, I'll create the `EnemyAISystem` and `DeathSystem` files.

I have created the `EnemyAISystem` at `EnemyAISystem.ts`. This system will handle enemy aggression, targeting, and attacks, making them an active threat to players.

I have also created the `DeathSystem` at `DeathSystem.ts`. This system is responsible for processing player and enemy deaths, including respawning players and removing enemies from the game.

Now, I will integrate these new ECS systems into the main game room. The existing `RuneRogueRoom.ts` is a legacy file, so I will apply the changes to the active `RuneRogueGameRoom.ts` located in the `@runerogue/server` package. I'll start by locating that file. I have refactored the schemas in `GameState.ts` to use a `Character` base class, reducing redundancy. I've also created the initial files for `EnemyAISystem.ts` and `DeathSystem.ts` within ``.

Now, I will integrate these new systems into the main game room logic. I'll start by modifying the `RuneRogueGameRoom.ts` to incorporate the `EnemyAISystem` and `DeathSystem`. This will bring the enemies to life and introduce consequences for combat. I will now proceed with the implementation of the requested features, focusing on enhancing the server-authoritative combat loop.

First, I'll refactor the `Player` and `Enemy` schemas in `GameState.ts` to use a `Character` base class. This will improve code maintainability by reducing redundancy. I'll also add the `isDead` property to the `Player` schema and an `aiState` to the `Enemy` schema to support the new death and AI systems. 
````

````
I will now proceed with the development plan, focusing on implementing the server-authoritative combat loop enhancements.

First, I'll refactor the `Player` and `Enemy` schemas in `GameState.ts` to use a `Character` base schema. This will improve code maintainability by reducing duplication. I will also add the `isDead` property to the `Player` schema and an `aiState` to the `Enemy` schema as requested. 
````

````
I have completed the first part of your request by refactoring the schemas and creating the `EnemyAISystem` and `DeathSystem`. Now, I will integrate these new systems into the main game room logic.

First, I'll add the new systems to the `RuneRogueGameRoom` and update the game loop to execute them. This will bring the enemy AI and death mechanics to life on the server. 
````

````
I have implemented the server-side systems for enemy AI and death handling, and refactored the game state schemas as requested. Now, I will integrate these new systems into the main game room and address the resulting linting errors to ensure the code is clean and correct.

First, I will fix the errors in `RuneRogueGameRoom.ts` and then proceed with the client-side implementations for animations and sound effects. 
````

````
I have implemented the server-side AI and death systems and refactored the game state schemas as requested. Now, I will address the remaining linting issues in `RuneRogueGameRoom.ts` to ensure code quality before moving on to the client-side enhancements. 
````

````
I have implemented the core server-side logic for enemy AI and death handling, and refactored the game state schemas for better maintainability. Here's a summary of the progress:

**Phase 1: Enemy AI and Aggression (Server-Side)**

*   **`EnemyAISystem.ts` Created:** A new ECS system now manages enemy behavior in `EnemyAISystem.ts`. It handles aggression, targeting, and movement. When an enemy is in range, it will now initiate an attack.
*   **`DeathSystem.ts` Created:** A corresponding system for handling entity death is located in `DeathSystem.ts`. It processes player and enemy deaths, respawning players and removing enemies from the game.

**Phase 4: Code Refinement (Server-Side)**

*   **Schema Refactoring:** The `Player` and `Enemy` schemas in `GameState.ts` have been refactored to inherit from a `Character` base schema. This reduces redundancy and improves the structure of the game state.
*   **Game Room Integration:** The new `EnemyAISystem` and `DeathSystem` have been integrated into the main game loop in `RuneRogueGameRoom.ts`. The game room now delegates AI and death logic to these dedicated systems, cleaning up the main room file and adhering to ECS principles.

I will now proceed with the client-side implementations for animations and sound, as well as handling the death events broadcast by the server. After that, I will add the necessary tests to ensure the new systems are working correctly.

---

_**User**_

 create a prompt for the next chat to carry out all the next steps

---

_**Assistant**_



---

