<!-- Generated by SpecStory -->

# # RuneRogue - Next Steps: Implementing the Core Co (2025-06-21 04:33:05)

_**User**_

# RuneRogue - Next Steps: Implementing the Core Combat Loop

Our current foundation is solid: the server is running, players can join a room, move around, and target enemies. The next critical phase is to bring the world to life by implementing the core combat loop. This will involve server-side logic for combat calculations and collision, as well as client-side rendering for enemies and visual feedback.

Our goal is to have a playable scenario where players can fight and defeat waves of enemies, with all mechanics adhering to the OSRS authenticity standards.

## Phase 1: Server-Side Gameplay Logic

### 1. Implement Collision-Based Combat

The `CombatSystem` needs to be updated to trigger attacks based on proximity, calculate damage using authentic OSRS formulas, and handle the consequences.

**File to Edit**: `packages/game-server/src/ecs/systems/CombatSystem.ts`

**Implementation Steps**:

1. **Add Required Imports**:

   ```typescript
   import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";
   import { defineQuery, defineSystem, IWorld } from "bitecs";
   import { Position, Health, Target, Combat } from "../components";
   ```

2. **Define the Combat Query**:

   ```typescript
   const combatQuery = defineQuery([Position, Health, Target, Combat]);
   const targetableQuery = defineQuery([Position, Health]);
   ```

3. **Implement Distance Calculation**:

   ```typescript
   function getDistance(
     x1: number,
     y1: number,
     x2: number,
     y2: number
   ): number {
     const dx = x2 - x1;
     const dy = y2 - y1;
     return Math.sqrt(dx * dx + dy * dy);
   }
   ```

4. **Create the Combat System**:

   ```typescript
   export const createCombatSystem = () => {
     return defineSystem((world: IWorld) => {
       const entities = combatQuery(world);
       const currentTime = performance.now();

       for (let i = 0; i < entities.length; i++) {
         const eid = entities[i];
         const targetEid = Target.eid[eid];

         // Verify target exists and is targetable
         if (!targetEid || !targetableQuery(world).includes(targetEid)) {
           continue;
         }

         // Check distance (1 tile = 32 pixels in our game)
         const distance = getDistance(
           Position.x[eid],
           Position.y[eid],
           Position.x[targetEid],
           Position.y[targetEid]
         );

         if (distance > 40) continue; // Slightly more than 1 tile for melee

         // Check attack timer (stored in milliseconds)
         const lastAttackTime = Combat.lastAttackTime[eid] || 0;
         const attackSpeed = Combat.attackSpeed[eid] || 2400; // 4-tick default

         if (currentTime - lastAttackTime < attackSpeed) continue;

         // Update attack timer
         Combat.lastAttackTime[eid] = currentTime;

         // Calculate combat using OSRS formulas
         const attackerStats = {
           attackLevel: Combat.attack[eid] || 1,
           strengthLevel: Combat.strength[eid] || 1,
           defenceLevel: Combat.defence[eid] || 1,
           attackBonus: 0, // TODO: Equipment bonuses
           strengthBonus: 0,
           defenceBonus: 0,
           attackStyle: "aggressive" as const,
           combatType: "melee" as const,
           prayers: [] as string[],
         };

         const defenderStats = {
           defenceLevel: Combat.defence[targetEid] || 1,
           defenceBonus: 0, // TODO: Equipment bonuses
           prayers: [] as string[],
         };

         // Calculate hit chance and damage
         const accuracy = calculateAccuracy(attackerStats, defenderStats);
         const maxHit = calculateMaxHit(attackerStats);

         // Roll for hit
         if (Math.random() < accuracy) {
           const damage = Math.floor(Math.random() * (maxHit + 1));
           Health.current[targetEid] = Math.max(
             0,
             Health.current[targetEid] - damage
           );

           // Emit damage event for client feedback
           // You'll need to pass the room instance to the system
           // world.room.broadcast("damage", { target: targetEid, damage, attacker: eid });
         }
       }

       return world;
     });
   };
   ```

5. **Add Attack Timer to Combat Component**:
   In `packages/game-server/src/ecs/components/index.ts`, update the Combat component:

   ```typescript
   export const Combat = defineComponent({
     attack: Types.ui8,
     strength: Types.ui8,
     defence: Types.ui8,
     attackSpeed: Types.ui16, // milliseconds between attacks
     lastAttackTime: Types.f32, // timestamp of last attack
   });
   ```

### 2. Handle Entity Death

When an entity's health drops to 0, it needs to be removed from the game.

**Files to Edit**:

- `packages/game-server/src/ecs/systems/CombatSystem.ts`
- `packages/game-server/src/rooms/GameRoom.ts`

**Implementation Steps**:

1. **Extend the Combat System** (in CombatSystem.ts):

   ```typescript
   // After applying damage in the combat system:
   if (Health.current[targetEid] <= 0) {
     // Mark entity for removal (don't remove during iteration)
     world.entitiesToRemove = world.entitiesToRemove || [];
     world.entitiesToRemove.push(targetEid);
   }
   ```

2. **Create Death Handler in GameRoom**:

   ```typescript
   // In GameRoom.ts, add a method to handle entity removal
   private handleEntityDeath(world: IWorld) {
     if (!world.entitiesToRemove || world.entitiesToRemove.length === 0) return;

     for (const eid of world.entitiesToRemove) {
       // Find if it's a player or enemy
       this.state.players.forEach((player, sessionId) => {
         if (player.ecsId === eid) {
           // Handle player death
           this.broadcast("playerDeath", { playerId: sessionId });
           // For now, respawn the player
           Health.current[eid] = Health.max[eid];
           Position.x[eid] = 400; // Spawn position
           Position.y[eid] = 300;
         }
       });

       this.state.enemies.forEach((enemy, enemyId) => {
         if (enemy.ecsId === eid) {
           // Handle enemy death
           this.broadcast("enemyDeath", { enemyId });
           this.state.enemies.delete(enemyId);
           removeEntity(world, eid);
         }
       });
     }

     world.entitiesToRemove = [];
   }
   ```

3. **Call Death Handler in Game Loop**:

   ```typescript
   // In GameRoom's simulation interval
   this.setSimulationInterval(() => {
     for (const system of this.systems) {
       system(this.world);
     }
     this.handleEntityDeath(this.world);
   });
   ```

### 3. Enhance Enemy Spawning and State

The `EnemySpawnSystem` should create fully-featured enemies that are synced to the client.

**Files to Edit**:

- `packages/shared/src/schemas/GameState.ts`
- `packages/game-server/src/ecs/systems/EnemySpawnSystem.ts`
- `packages/game-server/src/rooms/GameRoom.ts`

**Implementation Steps**:

1. **Define EnemySchema** in `packages/shared/src/schemas/GameState.ts`:

   ```typescript
   import { Schema, type, MapSchema } from "@colyseus/schema";

   export class EnemySchema extends Schema {
     @type("string") id: string = "";
     @type("number") ecsId: number = 0;
     @type("number") x: number = 0;
     @type("number") y: number = 0;
     @type("number") health: number = 0;
     @type("number") maxHealth: number = 0;
     @type("string") enemyType: string = "goblin"; // goblin, spider, etc.
     @type("number") combatLevel: number = 2;
   }

   export class GameRoomState extends Schema {
     @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
     @type({ map: EnemySchema }) enemies = new MapSchema<EnemySchema>();
     @type("number") waveNumber: number = 1;
     @type("number") enemiesRemaining: number = 0;
   }
   ```

2. **Create Enemy Spawn System**:

   ```typescript
   // packages/game-server/src/ecs/systems/EnemySpawnSystem.ts
   import { defineSystem, addEntity, addComponent, IWorld } from "bitecs";
   import {
     Position,
     Velocity,
     Health,
     Target,
     Combat,
     Enemy,
   } from "../components";
   import { EnemySchema } from "@runerogue/shared";
   import { GameRoom } from "../../rooms/GameRoom";

   interface SpawnConfig {
     health: number;
     attack: number;
     strength: number;
     defence: number;
     attackSpeed: number;
     combatLevel: number;
   }

   const ENEMY_CONFIGS: Record<string, SpawnConfig> = {
     goblin: {
       health: 5,
       attack: 1,
       strength: 1,
       defence: 1,
       attackSpeed: 2400, // 4 ticks
       combatLevel: 2,
     },
     spider: {
       health: 8,
       attack: 2,
       strength: 2,
       defence: 1,
       attackSpeed: 2400,
       combatLevel: 3,
     },
   };

   export const createEnemySpawnSystem = (room: GameRoom) => {
     let lastSpawnTime = 0;
     const SPAWN_INTERVAL = 5000; // 5 seconds

     return defineSystem((world: IWorld) => {
       const currentTime = performance.now();

       if (currentTime - lastSpawnTime < SPAWN_INTERVAL) {
         return world;
       }

       // Check if we should spawn enemies
       if (room.state.enemies.size < room.state.enemiesRemaining) {
         lastSpawnTime = currentTime;

         // Choose enemy type based on wave
         const enemyType = room.state.waveNumber > 3 ? "spider" : "goblin";
         const config = ENEMY_CONFIGS[enemyType];

         // Create ECS entity
         const eid = addEntity(world);

         // Add components
         addComponent(world, Position, eid);
         Position.x[eid] = 100 + Math.random() * 600;
         Position.y[eid] = 100 + Math.random() * 400;

         addComponent(world, Velocity, eid);
         addComponent(world, Health, eid);
         Health.current[eid] = config.health;
         Health.max[eid] = config.health;

         addComponent(world, Enemy, eid);
         addComponent(world, Target, eid);

         addComponent(world, Combat, eid);
         Combat.attack[eid] = config.attack;
         Combat.strength[eid] = config.strength;
         Combat.defence[eid] = config.defence;
         Combat.attackSpeed[eid] = config.attackSpeed;

         // Create and sync schema
         const enemySchema = new EnemySchema();
         enemySchema.id = `enemy_${eid}`;
         enemySchema.ecsId = eid;
         enemySchema.x = Position.x[eid];
         enemySchema.y = Position.y[eid];
         enemySchema.health = Health.current[eid];
         enemySchema.maxHealth = Health.max[eid];
         enemySchema.enemyType = enemyType;
         enemySchema.combatLevel = config.combatLevel;

         room.state.enemies.set(enemySchema.id, enemySchema);
       }

       // Update wave when all enemies are defeated
       if (room.state.enemies.size === 0 && room.state.enemiesRemaining === 0) {
         room.state.waveNumber++;
         room.state.enemiesRemaining = 3 + room.state.waveNumber * 2;
         room.broadcast("waveStart", {
           waveNumber: room.state.waveNumber,
           enemyCount: room.state.enemiesRemaining,
         });
       }

       return world;
     });
   };
   ```

3. **Add Enemy Component** in `packages/game-server/src/ecs/components/index.ts`:

   ```typescript
   export const Enemy = defineComponent({}); // Tag component
   ```

## Phase 2: Client-Side Rendering and Feedback

The client needs to render the full game state and provide visual feedback for combat.

**File to Edit**: `packages/phaser-client/src/scenes/GameScene.ts`

**Implementation Steps**:

1. **Create Enemy Container Map**:

   ```typescript
   private enemies: Map<string, Phaser.GameObjects.Container> = new Map();
   ```

2. **Listen for Enemy State Changes**:

   ```typescript
   // In setupStateHandlers method:
   this.room.state.enemies.onAdd((enemy, key) => {
     const container = this.add.container(enemy.x, enemy.y);

     // Create enemy sprite (use different colors for different types)
     const sprite = this.add.rectangle(
       0,
       0,
       24,
       24,
       enemy.enemyType === "goblin" ? 0x00ff00 : 0xff00ff
     );
     container.add(sprite);

     // Create health bar
     const healthBarBg = this.add.rectangle(0, -20, 30, 4, 0x000000);
     const healthBar = this.add.rectangle(0, -20, 30, 4, 0xff0000);
     container.add([healthBarBg, healthBar]);

     // Store references
     container.setData("sprite", sprite);
     container.setData("healthBar", healthBar);
     container.setData("maxHealth", enemy.maxHealth);

     this.enemies.set(key, container);
   });

   this.room.state.enemies.onChange((enemy, key) => {
     const container = this.enemies.get(key);
     if (!container) return;

     // Update position
     container.x = enemy.x;
     container.y = enemy.y;

     // Update health bar
     const healthBar = container.getData("healthBar");
     const maxHealth = container.getData("maxHealth");
     healthBar.scaleX = enemy.health / maxHealth;
   });

   this.room.state.enemies.onRemove((enemy, key) => {
     const container = this.enemies.get(key);
     if (container) {
       container.destroy();
       this.enemies.delete(key);
     }
   });
   ```

3. **Implement Damage Splats**:

   ```typescript
   // Listen for damage events
   this.room.onMessage("damage", (data: { target: number; damage: number }) => {
     // Find the target entity and show damage
     const targetPos = this.getEntityPosition(data.target);
     if (targetPos) {
       const damageText = this.add.text(
         targetPos.x,
         targetPos.y - 30,
         data.damage.toString(),
         {
           fontSize: "18px",
           color: "#ffff00",
           stroke: "#000000",
           strokeThickness: 2,
         }
       );

       // Animate the damage splat
       this.tweens.add({
         targets: damageText,
         y: targetPos.y - 50,
         alpha: 0,
         duration: 1000,
         onComplete: () => damageText.destroy(),
       });
     }
   });
   ```

4. **Add Death Animations**:

   ```typescript
   // Listen for death events
   this.room.onMessage("enemyDeath", (data: { enemyId: string }) => {
     const container = this.enemies.get(data.enemyId);
     if (container) {
       const sprite = container.getData("sprite");

       // Play death animation
       this.tweens.add({
         targets: sprite,
         scale: 0,
         angle: 360,
         alpha: 0,
         duration: 500,
         onComplete: () => {
           container.destroy();
           this.enemies.delete(data.enemyId);
         },
       });
     }
   });
   ```

5. **Create Wave UI**:

   ```typescript
   // Listen for wave start
   this.room.onMessage(
     "waveStart",
     (data: { waveNumber: number; enemyCount: number }) => {
       const waveText = this.add
         .text(
           400,
           50,
           `Wave ${data.waveNumber} - ${data.enemyCount} enemies!`,
           {
             fontSize: "32px",
             color: "#ffffff",
             stroke: "#000000",
             strokeThickness: 4,
           }
         )
         .setOrigin(0.5);

       // Fade out after 3 seconds
       this.time.delayedCall(3000, () => {
         this.tweens.add({
           targets: waveText,
           alpha: 0,
           duration: 1000,
           onComplete: () => waveText.destroy(),
         });
       });
     }
   );
   ```

## Testing the Implementation

1. **Start the servers**: `pnpm dev`
2. **Open multiple browser windows** to test multiplayer combat
3. **Verify the following**:
   - Enemies spawn at regular intervals
   - Players can click on enemies to target them
   - Combat occurs when in range
   - Damage numbers appear
   - Enemies disappear when killed
   - Wave progression works
   - All clients see the same game state

## Next Iterations

Once the core combat loop is working:

1. Add different attack animations
2. Implement proper sprite sheets
3. Add combat sounds
4. Create more enemy types with unique behaviors
5. Implement loot drops
6. Add player equipment that affects combat stats
7. Integrate the prayer system for combat bonuses

By completing these steps, we will have a functional and engaging core gameplay loop, paving the way for more advanced features like prayer, equipment, and varied enemy types.


---

_**Assistant**_

I will find all the code in the workspace relevant to implementing the core combat loop. This includes server-side logic for combat, collision, entity death, and enemy spawning, as well as client-side rendering for enemies and visual feedback.

Here are the files related to your request: I've analyzed the request to implement the core combat loop. Here are the relevant files and code snippets to help you get started.

First, I'll locate the key files involved in the server-side combat logic and the client-side rendering.

 To help you implement the core combat loop, I've gathered all the relevant files and their contents.

Here are the files related to your request:

***

### `packages/game-server/src/ecs/systems/CombatSystem.ts`

This file is where you'll implement the server-side combat logic, including proximity checks, damage calculation, and handling attack cooldowns.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\game-server\src\ecs\systems\CombatSystem.ts
import { defineQuery, defineSystem, type IWorld } from "bitecs";
import {
  Position,
  Target,
  Combat,
  Health,
  Player,
  Enemy,
} from "../components";
import { type GameRoom } from "../../rooms/GameRoom";
import { calculateMaxHit, calculateAccuracy } from "@runerogue/osrs-data";

const combatQuery = defineQuery([Position, Target, Combat]);
const targetableQuery = defineQuery([Position, Health]);

function getDistance(
  x1: number,
  y1: number,
  x2: number,
  y2: number
): number {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

export const createCombatSystem = (room: GameRoom) => {
  return defineSystem((world: IWorld) => {
    const entities = combatQuery(world);
    const currentTime = performance.now();

    for (let i = 0; i < entities.length; i++) {
      const eid = entities[i];
      const targetEid = Target.eid[eid];

      if (!targetEid || !targetableQuery(world).includes(targetEid)) {
        continue;
      }

      const distance = getDistance(
        Position.x[eid],
        Position.y[eid],
        Position.x[targetEid],
        Position.y[targetEid]
      );

      if (distance > 40) continue;

      const lastAttackTime = Combat.lastAttackTime[eid] || 0;
      const attackSpeed = Combat.attackSpeed[eid] || 2400;

      if (currentTime - lastAttackTime < attackSpeed) continue;

      Combat.lastAttackTime[eid] = currentTime;

      const isPlayerSource = Player.eid[eid] > 0;

      const attackerStats = {
        attackLevel: Combat.attack[eid] || 1,
        strengthLevel: Combat.strength[eid] || 1,
        defenceLevel: Combat.defence[eid] || 1,
        attackBonus: 0,
        strengthBonus: 0,
        defenceBonus: 0,
        attackStyle: "aggressive" as const,
        combatType: "melee" as const,
        prayers: [] as string[],
      };

      const defenderStats = {
        defenceLevel: Combat.defence[targetEid] || 1,
        defenceBonus: 0,
        prayers: [] as string[],
      };

      const accuracy = calculateAccuracy(attackerStats, defenderStats);
      const maxHit = calculateMaxHit(attackerStats);

      if (Math.random() < accuracy) {
        const damage = Math.floor(Math.random() * (maxHit + 1));
        const newHealth = Math.max(0, Health.current[targetEid] - damage);
        Health.current[targetEid] = newHealth;

        room.broadcast("damage", {
          targetId: targetEid,
          damage,
          isPlayerSource,
        });

        if (newHealth <= 0) {
          if (!world.entitiesToRemove) {
            world.entitiesToRemove = [];
          }
          world.entitiesToRemove.push(targetEid);
        }
      } else {
        room.broadcast("miss", { targetId: targetEid });
      }
    }

    return world;
  });
};
```

### `packages/game-server/src/rooms/GameRoom.ts`

In this file, you'll manage the game loop, systems, and handle entity death and spawning logic.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\game-server\src\rooms\GameRoom.ts
import { Room, Client } from "colyseus";
import {
  createWorld,
  addEntity,
  addComponent,
  defineQuery,
  removeEntity,
  type IWorld,
} from "bitecs";
import {
  Player,
  Position,
  Velocity,
  Target,
  Combat,
  Health,
} from "../ecs/components";
import { createMovementSystem } from "../ecs/systems/MovementSystem";
import { GameRoomState, PlayerSchema } from "@runerogue/shared";
import { createEnemySpawnSystem } from "../ecs/systems/EnemySpawnSystem";
import { createCombatSystem } from "../ecs/systems/CombatSystem";
import { createTargetingSystem } from "../ecs/systems/TargetingSystem";

const world = createWorld();

export class GameRoom extends Room<GameRoomState> {
  private systems: ((world: IWorld) => void)[] = [];

  onCreate(options: any) {
    this.setState(new GameRoomState());

    // Initialize systems
    this.systems.push(createMovementSystem());
    this.systems.push(createEnemySpawnSystem(this));
    this.systems.push(createCombatSystem(this));
    this.systems.push(createTargetingSystem());

    // Set simulation interval
    this.setSimulationInterval((deltaTime) => {
      world.time = { delta: deltaTime, elapsed: this.clock.elapsedTime };
      for (const system of this.systems) {
        system(world);
      }
      this.handleEntityDeath(world);
      this.syncState(world);
    });

    this.onMessage("move", (client, message) => {
      const player = this.state.players.get(client.sessionId);
      if (player) {
        const eid = player.ecsId;
        Position.x[eid] = message.x;
        Position.y[eid] = message.y;
      }
    });

    this.onMessage("attack", (client, message) => {
      const player = this.state.players.get(client.sessionId);
      if (player) {
        const eid = player.ecsId;
        Target.eid[eid] = message.targetId;
        this.broadcast("player_attack", { attackerId: eid });
      }
    });
  }

  onJoin(client: Client, options: any) {
    console.log(client.sessionId, "joined!");

    const eid = addEntity(world);

    addComponent(world, Player, eid);
    Player.sessionId[eid] = client.sessionId;

    addComponent(world, Position, eid);
    Position.x[eid] = Math.floor(Math.random() * 500);
    Position.y[eid] = Math.floor(Math.random() * 500);

    addComponent(world, Velocity, eid);
    addComponent(world, Target, eid);

    addComponent(world, Health, eid);
    Health.current[eid] = 100;
    Health.max[eid] = 100;

    addComponent(world, Combat, eid);
    Combat.attack[eid] = 10;
    Combat.strength[eid] = 10;
    Combat.defence[eid] = 10;
    Combat.attackSpeed[eid] = 2400;

    const playerSchema = new PlayerSchema();
    playerSchema.ecsId = eid;
    playerSchema.x = Position.x[eid];
    playerSchema.y = Position.y[eid];
    playerSchema.health = Health.current[eid];
    playerSchema.maxHealth = Health.max[eid];
    playerSchema.attack = Combat.attack[eid];
    playerSchema.strength = Combat.strength[eid];
    playerSchema.defence = Combat.defence[eid];

    this.state.players.set(client.sessionId, playerSchema);
  }

  onLeave(client: Client, consented: boolean) {
    console.log(client.sessionId, "left!");
    const player = this.state.players.get(client.sessionId);
    if (player) {
      removeEntity(world, player.ecsId);
      this.state.players.delete(client.sessionId);
    }
  }

  onDispose() {
    console.log("room", this.roomId, "disposing...");
  }

  private handleEntityDeath(world: IWorld) {
    if (!world.entitiesToRemove || world.entitiesToRemove.length === 0) return;

    for (const eid of world.entitiesToRemove) {
      let isPlayer = false;
      this.state.players.forEach((player, sessionId) => {
        if (player.ecsId === eid) {
          isPlayer = true;
          this.broadcast("playerDeath", { playerId: sessionId });
          Health.current[eid] = Health.max[eid];
          Position.x[eid] = 400;
          Position.y[eid] = 300;
        }
      });

      if (!isPlayer) {
        this.state.enemies.forEach((enemy, enemyId) => {
          if (enemy.ecsId === eid) {
            this.broadcast("enemyDeath", {
              enemyId,
              type: enemy.enemyType,
              x: enemy.x,
              y: enemy.y,
            });
            this.state.enemies.delete(enemyId);
            removeEntity(world, eid);
          }
        });
      }
    }

    world.entitiesToRemove = [];
  }

  private syncState(world: IWorld) {
    const playerQuery = defineQuery([Player, Position, Health, Combat]);
    const players = playerQuery(world);
    for (const eid of players) {
      const sessionId = Player.sessionId[eid].toString();
      const player = this.state.players.get(sessionId);
      if (player) {
        player.x = Position.x[eid];
        player.y = Position.y[eid];
        player.health = Health.current[eid];
      }
    }

    const enemyQuery = defineQuery([Position, Health, Combat]);
    const enemies = enemyQuery(world);
    this.state.enemies.forEach((enemy) => {
      if (enemies.includes(enemy.ecsId)) {
        enemy.x = Position.x[enemy.ecsId];
        enemy.y = Position.y[enemy.ecsId];
        enemy.health = Health.current[enemy.ecsId];
      }
    });
  }
}
```

### `packages/game-server/src/ecs/components/index.ts`

Here you'll add the `lastAttackTime` to the `Combat` component and define the `Enemy` tag component.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\game-server\src\ecs\components\index.ts
import { defineComponent, Types } from "bitecs";

export const Position = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

export const Velocity = defineComponent({
  x: Types.f32,
  y: Types.f32,
});

export const Player = defineComponent({
  sessionId: Types.ui8, // Assuming max 256 players for now
});

export const Enemy = defineComponent({});

export const Target = defineComponent({
  eid: Types.eid,
});

export const Health = defineComponent({
  current: Types.f32,
  max: Types.f32,
});

export const Combat = defineComponent({
  attack: Types.ui8,
  strength: Types.ui8,
  defence: Types.ui8,
  attackSpeed: Types.ui16,
  lastAttackTime: Types.f32,
});
```

### `packages/shared/src/schemas/GameState.ts`

This file defines the data structures that are synchronized between the server and the client. You'll define the `EnemySchema` here.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\shared\src\schemas\GameState.ts
import { Schema, type, MapSchema } from "@colyseus/schema";

export class PlayerSchema extends Schema {
  @type("number") ecsId: number = 0;
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 0;
  @type("number") maxHealth: number = 0;
  @type("number") attack: number = 0;
  @type("number") strength: number = 0;
  @type("number") defence: number = 0;
  @type("boolean") isDead: boolean = false;
}

export class EnemySchema extends Schema {
  @type("string") id: string = "";
  @type("number") ecsId: number = 0;
  @type("number") x: number = 0;
  @type("number") y: number = 0;
  @type("number") health: number = 0;
  @type("number") maxHealth: number = 0;
  @type("string") enemyType: string = "goblin";
  @type("number") combatLevel: number = 2;
}

export class GameRoomState extends Schema {
  @type({ map: PlayerSchema }) players = new MapSchema<PlayerSchema>();
  @type({ map: EnemySchema }) enemies = new MapSchema<EnemySchema>();
  @type("number") waveNumber: number = 1;
  @type("number") enemiesRemaining: number = 0;
}
```

### `packages/game-server/src/ecs/systems/EnemySpawnSystem.ts`

This system is responsible for spawning waves of enemies.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\game-server\src\ecs\systems\EnemySpawnSystem.ts
import { defineSystem, addEntity, addComponent, type IWorld } from "bitecs";
import {
  Position,
  Velocity,
  Health,
  Target,
  Combat,
  Enemy,
} from "../components";
import { EnemySchema } from "@runerogue/shared";
import { type GameRoom } from "../../rooms/GameRoom";

interface SpawnConfig {
  health: number;
  attack: number;
  strength: number;
  defence: number;
  attackSpeed: number;
  combatLevel: number;
}

const ENEMY_CONFIGS: Record<string, SpawnConfig> = {
  goblin: {
    health: 5,
    attack: 1,
    strength: 1,
    defence: 1,
    attackSpeed: 2400,
    combatLevel: 2,
  },
  spider: {
    health: 8,
    attack: 2,
    strength: 2,
    defence: 1,
    attackSpeed: 2400,
    combatLevel: 3,
  },
  skeleton: {
    health: 15,
    attack: 5,
    strength: 5,
    defence: 5,
    attackSpeed: 2400,
    combatLevel: 13,
  },
};

export const createEnemySpawnSystem = (room: GameRoom) => {
  let lastSpawnTime = 0;
  const SPAWN_INTERVAL = 5000;

  return defineSystem((world: IWorld) => {
    const currentTime = performance.now();

    if (
      room.state.enemies.size === 0 &&
      room.state.enemiesRemaining === 0
    ) {
      room.state.waveNumber++;
      room.state.enemiesRemaining = 3 + room.state.waveNumber * 2;
      room.broadcast("waveStart", {
        waveNumber: room.state.waveNumber,
        enemyCount: room.state.enemiesRemaining,
      });
    }

    if (
      currentTime - lastSpawnTime < SPAWN_INTERVAL ||
      room.state.enemies.size >= room.state.enemiesRemaining
    ) {
      return world;
    }

    lastSpawnTime = currentTime;

    const enemyType =
      room.state.waveNumber > 5
        ? "skeleton"
        : room.state.waveNumber > 2
          ? "spider"
          : "goblin";
    const config = ENEMY_CONFIGS[enemyType];

    const eid = addEntity(world);

    addComponent(world, Position, eid);
    Position.x[eid] = 100 + Math.random() * 600;
    Position.y[eid] = 100 + Math.random() * 400;

    addComponent(world, Velocity, eid);
    addComponent(world, Health, eid);
    Health.current[eid] = config.health;
    Health.max[eid] = config.health;

    addComponent(world, Enemy, eid);
    addComponent(world, Target, eid);

    addComponent(world, Combat, eid);
    Combat.attack[eid] = config.attack;
    Combat.strength[eid] = config.strength;
    Combat.defence[eid] = config.defence;
    Combat.attackSpeed[eid] = config.attackSpeed;

    const enemySchema = new EnemySchema();
    enemySchema.id = `enemy_${eid}`;
    enemySchema.ecsId = eid;
    enemySchema.x = Position.x[eid];
    enemySchema.y = Position.y[eid];
    enemySchema.health = Health.current[eid];
    enemySchema.maxHealth = Health.max[eid];
    enemySchema.enemyType = enemyType;
    enemySchema.combatLevel = config.combatLevel;

    room.state.enemies.set(enemySchema.id, enemySchema);

    return world;
  });
};
```

### `packages/phaser-client/src/scenes/GameScene.ts`

This is the main client-side file where you'll handle rendering enemies, damage splats, death animations, and UI updates.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\phaser-client\src/scenes\GameScene.ts
import Phaser from "phaser";
import {
  addComponent,
  addEntity,
  defineQuery,
  type IWorld,
  removeEntity,
} from "bitecs";
import { colyseusService } from "@/colyseus";
import {
  Player as PlayerComponent,
  Position,
  Enemy as EnemyComponent,
  Health,
  Stats,
} from "@/ecs/components";
import { createMainPipeline, world } from "@/ecs/world";
import type { Player, Enemy } from "@/types";
import { AudioManager } from "@/managers/AudioManager";
import { createAnimationSystem } from "@/systems/AnimationSystem";
import { NetworkManager } from "../network/NetworkManager";
import type { Room } from "colyseus.js";
import type { GameState as GameStateType } from "@/types";

const ATTACK_COOLDOWN_MS = 2400; // 4 ticks * 600ms

interface KeyboardKeys {
  W: Phaser.Input.Keyboard.Key;
  S: Phaser.Input.Keyboard.Key;
  A: Phaser.Input.Keyboard.Key;
  D: Phaser.Input.Keyboard.Key;
}

interface DamageMessage {
  targetId: number;
  damage: number;
  isPlayerSource: boolean;
}

/**
 * The main game scene where the action happens.
 */
export class GameScene extends Phaser.Scene {
  private pipeline!: (world: IWorld) => void;
  private eidToSprite = new Map<number, Phaser.GameObjects.Sprite>();
  private sessionIdToEid = new Map<string, number>();
  private enemyIdToEid = new Map<string, number>();
  private lastAttackTime = 0;
  private audioManager!: AudioManager;

  private networkManager!: NetworkManager;
  private players = new Map<string, Phaser.GameObjects.Sprite>();
  private enemies = new Map<string, Phaser.GameObjects.Container>();
  private healthBars = new Map<string, Phaser.GameObjects.Graphics>();
  private waveText!: Phaser.GameObjects.Text;
  private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;
  private wasd!: KeyboardKeys;

  constructor() {
    super({ key: "GameScene" });
  }

  /**
   * Preload assets for the scene.
   */
  preload(): void {
    // Create a mock AudioManager if the actual one has type issues
    try {
      this.audioManager = new AudioManager(this);
      this.audioManager.preload();
    } catch (error) {
      console.error("Failed to initialize AudioManager:", error);
      // Create a mock audio manager
      this.audioManager = {
        preload: () => {},
        create: () => {},
        play: (_sound: string) => {},
      } as AudioManager;
    }

    // TODO: Replace with actual OSRS-style assets
    this.load.image("player_placeholder", "assets/player_placeholder.png");
    this.load.image("enemy_placeholder", "assets/enemy_placeholder.png");

    // Load placeholder sprites
    this.load.image("player", "assets/player.png");
    this.load.image("goblin", "assets/goblin.png");
    this.load.image("spider", "assets/spider.png");
    this.load.image("skeleton", "assets/skeleton.png");
  }

  /**
   * Create game objects and set up event listeners.
   */
  create(): void {
    try {
      this.audioManager.create();
    } catch (error) {
      console.error("Failed to create AudioManager:", error);
    }

    // Generate a placeholder texture
    const graphics = this.add.graphics();
    graphics.fillStyle(0xff0000, 1); // Red square
    graphics.fillRect(0, 0, 32, 32);
    graphics.generateTexture("player_placeholder", 32, 32);
    graphics.destroy();

    const room = colyseusService.room as Room<GameStateType> | null;
    if (!room) {
      console.error("Colyseus room not available in GameScene");
      return;
    }

    // Simple input listener for testing combat
    this.input.keyboard?.on("keydown-SPACE", () => {
      const now = Date.now();
      if (now - this.lastAttackTime < ATTACK_COOLDOWN_MS) {
        return; // Client-side cooldown
      }

      const playerEid = this.sessionIdToEid.get(room.sessionId);
      if (playerEid === undefined) return;

      // Find the closest enemy to attack
      const closestEnemy = this.findClosestEnemy(playerEid);
      if (closestEnemy) {
        this.lastAttackTime = now;
        room.send("attack", { targetId: closestEnemy.eid });
        console.info(`Sent attack request for target ${closestEnemy.eid}`);
      }
    });

    this.cameras.main.setBackgroundColor("#2d2d2d");

    try {
      this.pipeline = createMainPipeline(this);
      const animationSystem = createAnimationSystem(this, this.eidToSprite);

      const originalPipeline = this.pipeline;
      this.pipeline = (world) => {
        originalPipeline(world);
        if (colyseusService.room?.state) {
          animationSystem(world, colyseusService.room.state);
        }
      };
    } catch (error) {
      console.error("Failed to create pipeline:", error);
      this.pipeline = (_world: IWorld) => {}; // No-op pipeline
    }

    // Initial player setup
    room.state.players.forEach((player: Player, sessionId: string) => {
      this.addPlayer(player, sessionId);
    });

    // Listen for new players joining
    room.state.players.onAdd((player: Player, sessionId: string) => {
      this.addPlayer(player, sessionId);
    });

    // Listen for players leaving
    room.state.players.onRemove((_player: Player, sessionId: string) => {
      const eid = this.sessionIdToEid.get(sessionId);
      if (eid !== undefined && colyseusService.room) {
        const player = colyseusService.room.state.players.get(sessionId);
        if (player && "isDead" in player && player.isDead) {
          this.audioManager.play("player-death");
        }
      }
      this.removePlayer(sessionId);
    });

    // Listen for player state changes
    room.state.players.onChange((player: Player, sessionId: string) => {
      const eid = this.sessionIdToEid.get(sessionId);
      if (eid === undefined) return;

      const currentHealthComponent = Health.current as Float32Array;
      const oldHealth = currentHealthComponent[eid];
      if (oldHealth > player.health) {
        this.audioManager.play("hit-splat");
        this.showDamageSplat(eid, oldHealth - player.health, false);
      }

      this.updatePlayer(player, sessionId);
    });

    // Initial enemy setup
    room.state.enemies.forEach((enemy: Enemy, enemyId: string) => {
      this.addEnemy(enemy, enemyId);
    });

    // Listen for new enemies
    room.state.enemies.onAdd((enemy: Enemy, enemyId: string) => {
      this.addEnemy(enemy, enemyId);
    });

    // Listen for enemies leaving
    room.state.enemies.onRemove((_enemy: Enemy, enemyId: string) => {
      const eid = this.enemyIdToEid.get(enemyId);
      if (eid !== undefined) {
        // The server now removes enemies after a delay, so we can play the sound here.
        this.audioManager.play("enemy-death");
      }
      this.removeEnemy(enemyId);
    });

    // Listen for enemy state changes
    room.state.enemies.onChange((enemy: Enemy, enemyId: string) => {
      const eid = this.enemyIdToEid.get(enemyId);
      if (eid === undefined) return;

      const currentHealthComponent = Health.current as Float32Array;
      const oldHealth = currentHealthComponent[eid];
      if (oldHealth > enemy.health) {
        this.audioManager.play("hit-splat");
        this.showDamageSplat(eid, oldHealth - enemy.health, true); // Assuming enemy damage is from player
      }

      this.updateEnemy(enemy, enemyId);
    });

    room.onMessage("player_attack", (_message: unknown) => {
      this.audioManager.play("attack-swoosh");
    });

    room.onMessage("damage", (message: DamageMessage) => {
      const { targetId, damage, isPlayerSource } = message;
      const targetSprite = this.eidToSprite.get(targetId);
      if (targetSprite) {
        this.audioManager.play("hit-splat");
        this.showDamageSplat(targetId, damage, isPlayerSource);
      }
    });

    // Enable physics
    this.physics.world.setBounds(0, 0, 800, 600);

    // Create background
    this.add.rectangle(400, 300, 800, 600, 0x2d2d2d);

    // Create UI
    this.waveText = this.add.text(10, 10, "Wave: 1", {
      fontSize: "20px",
      color: "#ffffff",
    });

    // Setup input
    this.cursors = this.input.keyboard.createCursorKeys();
    this.wasd = this.input.keyboard.addKeys("W,S,A,D") as KeyboardKeys;

    // Setup network manager
    try {
      this.networkManager = NetworkManager.getInstance();
      this.setupNetworkHandlers();
    } catch (error) {
      console.error("Failed to setup NetworkManager:", error);
    }

    // Mouse input for attacks
    this.input.on("pointerdown", (pointer: Phaser.Input.Pointer) => {
      this.handleAttack(pointer);
    });
  }

  /**
   * The main update loop, called on every frame.
   * @param {number} _time - The current time.
   * @param {number} _delta - The delta time in ms since the last frame.
   */
  update(_time: number, _delta: number): void {
    if (!this.pipeline) return;
    this.pipeline(world);

    // Handle player movement
    if (this.networkManager) {
      const sessionId = this.networkManager.getSessionId();
      const player = this.players.get(sessionId);
      if (player) {
        let vx = 0;
        let vy = 0;

        if (this.cursors.left.isDown || this.wasd.A.isDown) vx = -200;
        if (this.cursors.right.isDown || this.wasd.D.isDown) vx = 200;
        if (this.cursors.up.isDown || this.wasd.W.isDown) vy = -200;
        if (this.cursors.down.isDown || this.wasd.S.isDown) vy = 200;

        if (vx !== 0 || vy !== 0) {
          // Normalize diagonal movement
          if (vx !== 0 && vy !== 0) {
            vx *= 0.707;
            vy *= 0.707;
          }

          const newX = player.x + (vx * this.game.loop.delta) / 1000;
          const newY = player.y + (vy * this.game.loop.delta) / 1000;

          player.setPosition(newX, newY);
          this.networkManager.sendMove(newX, newY);
        }
      }
    }

    // Update health bars
    this.updateHealthBars();
  }

  private setupNetworkHandlers(): void {
    if (!this.networkManager) return;
    const room = this.networkManager.getRoom() as Room<GameStateType> | null;
    if (!room) return;

    // Handle player updates
    room.state.players.onAdd = (player: Player, key: string) => {
      const sprite = this.physics.add.sprite(player.x, player.y, "player");
      sprite.setData("playerId", key);
      this.players.set(key, sprite);

      // Create health bar
      const healthBar = this.add.graphics();
      this.healthBars.set(`player_${key}`, healthBar);
    };

    room.state.players.onRemove = (_player: Player, key: string) => {
      const sprite = this.players.get(key);
      if (sprite) {
        sprite.destroy();
        this.players.delete(key);
      }

      const healthBar = this.healthBars.get(`player_${key}`);
      if (healthBar) {
        healthBar.destroy();
        this.healthBars.delete(`player_${key}`);
      }
    };

    room.state.players.onChange = (player: Player, key: string) => {
      const sprite = this.players.get(key);
      if (
        sprite &&
        this.networkManager &&
        key !== this.networkManager.getSessionId()
      ) {
        sprite.setPosition(player.x, player.y);
        sprite.setAlpha(player.isDead ? 0.3 : 1);
      }
    };

    // Handle enemy updates
    room.state.enemies.onAdd = (enemy: Enemy, key: string) => {
      const container = this.add.container(enemy.x, enemy.y);

      // Create enemy sprite (use different colors for different types)
      const colors = {
        goblin: 0x00ff00,
        spider: 0xff00ff,
        orc: 0xff0000,
      };
      const color = colors[enemy.enemyType as keyof typeof colors] || 0x808080;

      const sprite = this.add.rectangle(0, 0, 24, 24, color);
      container.add(sprite);

      // Create health bar background
      const healthBarBg = this.add.rectangle(0, -20, 30, 4, 0x000000);
      healthBarBg.setStrokeStyle(1, 0xffffff);

      // Create health bar
      const healthBar = this.add.rectangle(0, -20, 30, 4, 0xff0000);
      healthBar.setOrigin(0.5, 0.5);

      container.add([healthBarBg, healthBar]);

      // Add combat level text
      const levelText = this.add
        .text(0, 8, enemy.combatLevel.toString(), {
          fontSize: "10px",
          color: "#ffffff",
          stroke: "#000000",
          strokeThickness: 2,
        })
        .setOrigin(0.5, 0);
      container.add(levelText);

      // Store references
      container.setData("sprite", sprite);
      container.setData("healthBar", healthBar);
      container.setData("healthBarBg", healthBarBg);
      container.setData("maxHealth", enemy.maxHealth);
      container.setData("ecsId", enemy.ecsId);

      // Make enemy clickable for targeting
      sprite.setInteractive();
      sprite.on("pointerdown", () => {
        this.room?.send("setTarget", { targetId: enemy.ecsId });
      });

      this.enemies.set(key, container);
    };

    this.room.state.enemies.onChange((enemy, key) => {
      const container = this.enemies.get(key);
      if (!container) return;

      // Update position with smooth interpolation
      this.tweens.add({
        targets: container,
        x: enemy.x,
        y: enemy.y,
        duration: 100,
        ease: "Linear",
      });

      // Update health bar
      const healthBar = container.getData(
        "healthBar"
      ) as Phaser.GameObjects.Rectangle;
      const maxHealth = container.getData("maxHealth") as number;
      const healthPercent = Math.max(0, enemy.health / maxHealth);
      healthBar.scaleX = healthPercent;

      // Change health bar color based on percentage
      if (healthPercent <= 0.25) {
        healthBar.setFillStyle(0x800000); // Dark red
      } else if (healthPercent <= 0.5) {
        healthBar.setFillStyle(0xff8800); // Orange
      }
    });

    this.room.state.enemies.onRemove((enemy, key) => {
      const container = this.enemies.get(key);
      if (container) {
        container.destroy();
        this.enemies.delete(key);
      }
    });

    // Combat event handlers
    this.room.onMessage(
      "damage",
      (data: {
        target: number;
        damage: number;
        attacker: number;
        remainingHealth: number;
      }) => {
        const targetPos = this.getEntityPosition(data.target);
        if (targetPos) {
          this.showDamageSplat(targetPos.x, targetPos.y, data.damage);
        }
      }
    );

    this.room.onMessage(
      "combatMiss",
      (data: { target: number; attacker: number }) => {
        const targetPos = this.getEntityPosition(data.target);
        if (targetPos) {
          this.showMissSplat(targetPos.x, targetPos.y);
        }
      }
    );

    this.room.onMessage(
      "enemyDeath",
      (data: { enemyId: string; type: string; x: number; y: number }) => {
        const container = this.enemies.get(data.enemyId);
        if (container) {
          const sprite = container.getData(
            "sprite"
          ) as Phaser.GameObjects.Rectangle;

          // Play death animation
          this.tweens.add({
            targets: sprite,
            scale: 0,
            angle: 360,
            alpha: 0,
            duration: 500,
            onComplete: () => {
              container.destroy();
              this.enemies.delete(data.enemyId);
            },
          });
        }
      }
    );

    this.room.onMessage(
      "waveStart",
      (data: { waveNumber: number; enemyCount: number }) => {
        this.showWaveAnnouncement(data.waveNumber, data.enemyCount);
      }
    );
  }

  /**
   * Get entity position by ECS ID
   */
  private getEntityPosition(ecsId: number): { x: number; y: number } | null {
    // Check players
    for (const [_, player] of this.players) {
      const playerEcsId = player.getData("ecsId");
      if (playerEcsId === ecsId) {
        return { x: player.x, y: player.y };
      }
    }

    // Check enemies
    for (const [_, enemy] of this.enemies) {
      const enemyEcsId = enemy.getData("ecsId");
      if (enemyEcsId === ecsId) {
        return { x: enemy.x, y: enemy.y };
      }
    }

    return null;
  }

  /**
   * Show damage splat animation
   */
  private showDamageSplat(x: number, y: number, damage: number): void {
    const damageText = this.add
      .text(x, y - 30, damage.toString(), {
        fontSize: "18px",
        color: "#ffff00",
        stroke: "#000000",
        strokeThickness: 2,
      })
      .setOrigin(0.5);

    // Animate the damage splat
    this.tweens.add({
      targets: damageText,
      y: y - 50,
      alpha: 0,
      duration: 1000,
      ease: "Cubic.easeOut",
      onComplete: () => {
        damageText.destroy();
      },
    });
  }

  /**
   * Show miss splat animation
   */
  private showMissSplat(x: number, y: number): void {
    const missText = this.add
      .text(x, y - 30, "Miss", {
        fontSize: "16px",
        color: "#0088ff",
        stroke: "#000000",
        strokeThickness: 2,
      })
      .setOrigin(0.5);

    // Animate the miss splat
    this.tweens.add({
      targets: missText,
      y: y - 45,
      alpha: 0,
      duration: 800,
      ease: "Cubic.easeOut",
      onComplete: () => {
        missText.destroy();
      },
    });
  }

  /**
   * Show wave announcement
   */
  private showWaveAnnouncement(waveNumber: number, enemyCount: number): void {
    const waveText = this.add
      .text(400, 50, `Wave ${waveNumber} - ${enemyCount} enemies!`, {
        fontSize: "32px",
        color: "#ffffff",
        stroke: "#000000",
        strokeThickness: 4,
      })
      .setOrigin(0.5)
      .setScrollFactor(0); // UI element

    // Entrance animation
    waveText.setScale(0);
    this.tweens.add({
      targets: waveText,
      scale: 1,
      duration: 300,
      ease: "Back.easeOut",
    });

    // Fade out after 3 seconds
    this.time.delayedCall(3000, () => {
      this.tweens.add({
        targets: waveText,
        alpha: 0,
        scale: 0.8,
        duration: 1000,
        ease: "Cubic.easeIn",
        onComplete: () => {
          waveText.destroy();
        },
      });
    });
  }

  /**
   * Adds a new player entity and its sprite to the scene.
   * @param {Player} player - The player data from the server.
   * @param {string} sessionId - The player's session ID.
   */
  private addPlayer(player: Player, sessionId: string): void {
    const eid = addEntity(world);
    this.sessionIdToEid.set(sessionId, eid);

    addComponent(world, Position, eid);
    const posX = Position.x as Float32Array;
    const posY = Position.y as Float32Array;
    posX[eid] = player.x;
    posY[eid] = player.y;

    addComponent(world, PlayerComponent, eid);
    addComponent(world, Health, eid);
    const healthCurrent = Health.current as Float32Array;
    const healthMax = Health.max as Float32Array;
    healthCurrent[eid] = player.health;
    healthMax[eid] = player.maxHealth;

    addComponent(world, Stats, eid);
    const statsAttack = Stats.attack as Float32Array;
    const statsStrength = Stats.strength as Float32Array;
    const statsDefence = Stats.defence as Float32Array;
    statsAttack[eid] = player.attack;
    statsStrength[eid] = player.strength;
    statsDefence[eid] = player.defence;

    const sprite = this.add.sprite(player.x, player.y, "player_placeholder");
    this.eidToSprite.set(eid, sprite);
  }

  /**
   * Removes a player entity and its sprite from the scene.
   * @param {string} sessionId - The session ID of the player to remove.
   */
  private removePlayer(sessionId: string): void {
    const eid = this.sessionIdToEid.get(sessionId);
    if (eid === undefined) return;

    const sprite = this.eidToSprite.get(eid);
    if (sprite) {
      sprite.destroy();
    }

    removeEntity(world, eid);
    this.eidToSprite.delete(eid);
    this.sessionIdToEid.delete(sessionId);
  }

  /**
   * Updates a player's entity data.
   * @param {Player} player - The updated player data from the server.
   * @param {string} sessionId - The player's session ID.
   */
  private updatePlayer(player: Player, sessionId: string): void {
    const eid = this.sessionIdToEid.get(sessionId);
    if (eid === undefined) return;

    Position.x[eid] = player.x;
    Position.y[eid] = player.y;

    const health = Health.current[eid];
    if (health !== player.health) {
      Health.current[eid] = player.health;
    }
  }

  /**
   * Adds a new enemy entity and its sprite to the scene.
   * @param {Enemy} enemy - The enemy data from the server.
   * @param {string} enemyId - The enemy's ID.
   */
  private addEnemy(enemy: Enemy, enemyId: string): void {
    const eid = addEntity(world);
    this.enemyIdToEid.set(enemyId, eid);

    addComponent(world, Position, eid);
    const posX = Position.x as Float32Array;
    const posY = Position.y as Float32Array;
    posX[eid] = enemy.x;
    posY[eid] = enemy.y;

    addComponent(world, EnemyComponent, eid);
    addComponent(world, Health, eid);
    const healthCurrent = Health.current as Float32Array;
    const healthMax = Health.max as Float32Array;
    healthCurrent[eid] = enemy.health;
    healthMax[eid] = enemy.maxHealth;

    addComponent(world, Stats, eid);
    const statsAttack = Stats.attack as Float32Array;
    const statsStrength = Stats.strength as Float32Array;
    const statsDefence = Stats.defence as Float32Array;
    statsAttack[eid] = enemy.attack;
    statsStrength[eid] = enemy.strength;
    statsDefence[eid] = enemy.defence;

    const sprite = this.add.sprite(enemy.x, enemy.y, "enemy_placeholder");
    this.eidToSprite.set(eid, sprite);
  }

  /**
   * Removes an enemy entity and its sprite from the scene.
   * @param {string} enemyId - The ID of the enemy to remove.
   */
  private removeEnemy(enemyId: string): void {
    const eid = this.enemyIdToEid.get(enemyId);
    if (eid === undefined) return;

    const sprite = this.eidToSprite.get(eid);
    if (sprite) {
      sprite.destroy();
    }

    removeEntity(world, eid);
    this.eidToSprite.delete(eid);
    this.enemyIdToEid.delete(enemyId);
  }

  /**
   * Updates an enemy's entity data.
   * @param {Enemy} enemy - The updated enemy data from the server.
   * @param {string} enemyId - The enemy's ID.
   */
  private updateEnemy(enemy: Enemy, enemyId: string): void {
    const eid = this.enemyIdToEid.get(enemyId);
    if (eid === undefined) return;

    Position.x[eid] = enemy.x;
    Position.y[eid] = enemy.y;

    const health = Health.current[eid];
    if (health !== enemy.health) {
      Health.current[eid] = enemy.health;
    }
  }

  private showDamageSplat(
    entityId: number,
    damage: number,
    isPlayerSource: boolean
  ) {
    const targetSprite = this.eidToSprite.get(entityId);
    if (!targetSprite) return;

    const x = targetSprite.x;
    const y = targetSprite.y - 20; // Offset above the sprite

    let color = "#ff0000"; // Red for damage to player/from enemy
    if (isPlayerSource) {
      color = damage > 0 ? "#0000ff" : "#ffffff"; // Blue for damage dealt by player, white for a miss
    }

    const text = this.add.text(x, y, damage.toString(), {
      fontFamily: "'RuneScape UF'",
      fontSize: "16px",
      color: color,
      stroke: "#000000",
      strokeThickness: 2,
    });
    text.setOrigin(0.5, 0.5);

    this.tweens.add({
      targets: text,
      y: y - 30,
      alpha: 0,
      duration: 1000,
      ease: "Power1",
      onComplete: () => {
        text.destroy();
      },
    });
  }

  private findClosestEnemy(
    playerId: number
  ): { eid: number; dist: number } | null {
    const playerX = Position.x[playerId];
    const playerY = Position.y[playerId];
    const enemyQuery = defineQuery([EnemyComponent, Position]);
    const enemies = enemyQuery(world);

    let closestDist = Infinity;
    let closestEnemyEid: number | null = null;

    for (const enemyEid of enemies) {
      const enemyX = Position.x[enemyEid];
      const enemyY = Position.y[enemyEid];
      const dist = Phaser.Math.Distance.Between(
        playerX,
        playerY,
        enemyX,
        enemyY
      );

      if (dist < closestDist) {
        closestDist = dist;
        closestEnemyEid = enemyEid;
      }
    }

    if (closestEnemyEid !== null) {
      return { eid: closestEnemyEid, dist: closestDist };
    }

    return null;
  }

  /**
   * Provides the map of entity IDs to their corresponding Phaser sprites.
   * This is used by rendering systems to update the visual representation of entities.
   * @returns {Map<number, Phaser.GameObjects.Sprite>} The eid-to-sprite map.
   */
  public getSpriteMap(): Map<number, Phaser.GameObjects.Sprite> {
    return this.eidToSprite;
  }
}
```

### `packages/osrs-data/src/index.ts`

This file contains the core OSRS combat calculation formulas that you'll import and use in the `CombatSystem`.

```typescript
// filepath: c:\Users\aggis\GitHub\runerogue\packages\osrs-data\src\index.ts
export * from "./constants";
export * from "./combat";
```
````

````
My apologies, I missed updating the `GameRoom.ts` file to correctly handle entity death and wire up the systems. I will correct that now, and then proceed with the client-side changes in `GameScene.ts`.

First, I'll apply the necessary changes to `GameRoom.ts`. 
````

````
I will start by implementing the server-side logic for combat, entity death, and enemy spawning.

First, I'll update the `Combat` component in `index.ts` to include an attack timer, and I'll add a new `Enemy` component. 
````

````
I've updated the schemas and component definitions. Now, I'll implement the core combat logic.

First, I'll create the `EnemySpawnSystem.ts` to manage spawning enemies in waves. I have updated the `GameRoomState` schema and the `Combat` component as you requested. Now, I will replace the content of `EnemySpawnSystem.ts` with the new implementation you provided. 
````

````
I have implemented the server-side logic. Now, I will update the client to render enemies, display combat feedback like damage splats, and show wave announcements. 
````

````
Of course. I will now implement the core combat loop, including server-side logic and client-side rendering.

First, I'll update the shared game state schema to ensure waves start at wave 1 and to include enemy data. 
````

````
I have implemented the server-side logic for combat, entity death, and enemy spawning. Now, I will proceed with the client-side changes to render the game state and provide visual feedback for combat.

I will now edit `GameScene.ts` to integrate the client-side rendering and feedback logic. This includes creating enemy sprites, handling state changes, displaying damage splats, showing death animations, and creating the wave announcement UI.

---

_**User**_

@agent Try Again

---

_**Assistant**_



---

